var Playspecs=function(t){var e={};function r(n){if(e[n])return e[n].exports;var s=e[n]={i:n,l:!1,exports:{}};return t[n].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},r.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){"use strict";r.r(e);const n={WHITESPACE:" ",CONCATENATION:",",DOTS_GREEDY:"...",DOTS_RELUCTANT:"..",DOTS_OMEGA:"***",LEFT_PAREN:"(",RIGHT_PAREN:")",CAPTURING_LEFT_PAREN:"$(",ALTERNATION:";",INTERSECTION:"^",AND:"&",OR:"|",NOT:"not",START:"start",END:"end",TRUE:"true",FALSE:"false",ERROR:"error"},s={OMEGA:n.DOTS_OMEGA,REPETITION:n.DOTS_GREEDY,CONCATENATION:n.CONCATENATION,CAPTURE:"$(",GROUP:n.LEFT_PAREN,ALTERNATION:n.ALTERNATION,INTERSECTION:n.INTERSECTION,AND:n.AND,OR:n.OR,NOT:n.NOT,START:n.START,END:n.END,TRUE:n.TRUE,FALSE:n.FALSE,ERROR:n.ERROR};function i(t){return{type:t.type,value:t.value,children:t.children.slice(),range:{start:t.range.start,end:t.range.end}}}const a=function(t){return function(e){return t}},c=function(t,e){return t.node(e.type,e.value)},o=function(t,e,r){let n=[e];return n.push(t.parseExpression(r.tightness-1)),t.node(r.type,r.value,n)},h=function(t,e,r){if(!f(e))return t.error("Left hand side of token must be propositional",r,e);let n=[e];const s=t.parseExpression(r.tightness-1);return f(s)?(n.push(s),t.node(r.type,r.value,n)):t.error("Right hand side of token must be propositional",r,s)},u="$END",l=[{type:n.WHITESPACE,match:/^\s+/},{type:n.CONCATENATION,match:[n.CONCATENATION],tightness:100,extendParse:o},{type:n.DOTS_GREEDY,match:/^([0-9]*)\s*\.\.\.\s*([0-9]*)/,value:function(t){return{greedy:!0,lowerBound:t[1]?parseInt(t[1]):0,upperBound:t[2]?parseInt(t[2]):u}},tightness:110,startParse:function(t,e){const r=t.node(s.TRUE,!0);return r.range.start=e.range.start,r.range.end=e.range.start,t.node(s.REPETITION,e.value,[r])},extendParse:function(t,e,r){return t.node(s.REPETITION,r.value,[e])}},{type:n.DOTS_RELUCTANT,match:/^([0-9]*)\s*\.\.\s*([0-9]*)/,tightness:110,value:function(t){return{greedy:!1,lowerBound:t[1]?parseInt(t[1]):0,upperBound:t[2]?parseInt(t[2]):u}},startParse:function(t,e){const r=t.node(s.TRUE,!0);return r.range.start=e.range.start,r.range.end=e.range.start,t.node(s.REPETITION,e.value,[r])},extendParse:function(t,e,r){return t.node(s.REPETITION,r.value,[e])}},{type:n.DOTS_OMEGA,match:[n.DOTS_OMEGA],tightness:110,startParse:function(t,e){const r=t.node(s.TRUE,!0);return r.range.start=e.range.start,r.range.end=e.range.end,t.node(s.OMEGA,e.value,[r])},extendParse:function(t,e,r){return t.node(s.OMEGA,r.value,[e])}},{type:n.LEFT_PAREN,match:[n.LEFT_PAREN],startParse:function(t,e){const r=t.parseExpression(0);return t.currentToken().type!=n.RIGHT_PAREN?t.error("Missing right parenthesis",e,r):(t.advance(),t.node(s.GROUP,e.value,[r]))}},{type:n.RIGHT_PAREN,match:[n.RIGHT_PAREN]},{type:n.CAPTURING_LEFT_PAREN,match:/^\$([A-z_][A-z_0-9]*)?\(/,value:function(t){return{group:t[1]||"$implicit"}},startParse:function(t,e){const r=t.parseExpression(0);return t.currentToken().type!=n.RIGHT_PAREN?t.error("Missing right parenthesis",e,r):(t.advance(),t.node(s.CAPTURE,e.value,[r]))}},{type:n.ALTERNATION,match:[n.ALTERNATION],tightness:60,extendParse:o},{type:n.INTERSECTION,match:[n.INTERSECTION],tightness:50,extendParse:o},{type:n.AND,match:[n.AND],tightness:200,extendParse:h},{type:n.OR,match:[n.OR],tightness:210,extendParse:h},{type:n.NOT,match:[n.NOT],tightness:220,startParse:function(t,e){const r=t.parseExpression(e.tightness);return f(r)?t.node(e.type,e.value,[r]):t.error("NOT may only negate propositional state formulae",e,r)}},{type:n.START,match:[n.START],startParse:c},{type:n.END,match:[n.END],startParse:c},{type:n.TRUE,match:[n.TRUE],value:a(!0),startParse:c},{type:n.FALSE,match:[n.FALSE],value:a(!1),startParse:c},{type:n.ERROR,match:/^\S+/,startParse:c}],p=300,d="ERROR";function g(t){for(var e in s)if(s[e]==t.type)return!1;return!0}function f(t){return g(t)||t.type==s.AND||t.type==s.OR||t.type==s.NOT||t.type==s.TRUE||t.type==s.FALSE||t.type==s.START||t.type==s.END||(t.type==s.GROUP||t.type==s.CAPTURE)&&t.children.every(function(t){return f(t)})}class y{constructor(t){this.tokenDefinitions=[],this.tokensByType={},this.parseErrors=[];const e=t||[],r=e.concat(l);for(let t=0;t<r.length;t++){const n=r[t],s=n.tightness||0,i={type:n.type,match:n.match instanceof RegExp?n.match:"string"==typeof n.match?[n.match]:n.match,value:n.value||function(t){return t[0]},tightness:t<e.length?s+p:s,startParse:n.startParse||function(t,e){return t.error("Can't start a parse tree with this token",e)},extendParse:n.extendParse||function(t,e,r){return t.error("Can't extend a parse tree with this token",r,e)}};this.tokenDefinitions.push(i),this.tokensByType[i.type]=i}this.resetStream()}node(t,e,r=[]){return{type:t,value:e,children:r,range:{start:-1,end:-1}}}error(t,e,r){const n=this.node(d,{message:t,token:e,tree:r});return this.parseErrors.push(n),n}tokenize(t){let e=[],r=[],s=t,i=0;for(;s.length;)for(let t=0;t<this.tokenDefinitions.length;t++){const a=this.tokenDefinitions[t],c=a.match;let o={match:null,index:-1};if(c instanceof RegExp){let t=c.exec(s);t&&(o.match=t,o.index=t.index)}else if(Array.isArray(c))for(let t=0;t<c.length;t++){const e=c[t];s.substr(0,e.length)==e&&(o.match=[e],o.index=0)}if(o.match&&0==o.index){const t=o.match[0].length;s=s.substr(o.match[0].length);const c=i;i+=t,a.type!==n.WHITESPACE&&(a.type===n.ERROR&&r.push(e.length),e.push({type:a.type,value:a.value(o.match),tightness:a.tightness||0,range:{start:c,end:i}}));break}}return{string:t,tokens:e,position:0,errors:r}}resetStream(){this.stream={string:"",tokens:[],position:0,errors:[]}}charPosition(){return this.currentToken()?this.currentToken().range.start:this.stream.string.length}remainder(){const t=this.charPosition();return this.stream.string.substr(t)}currentToken(){return this.stream.tokens[this.stream.position]}advance(){this.stream.position++}parse(t){this.stream=this.tokenize(t),this.parseErrors=[];var e={tree:this.parseExpression(0),errors:this.parseErrors,remainder:this.remainder()};return this.parseErrors=[],this.resetStream(),e}parseExpression(t){let e=this.currentToken(),r=this.tokensByType[e.type];const n=e.range.start;this.advance();let s=r.startParse(this,e);if(s.range.start=n,s.range.end=this.charPosition(),s.type==d)return s;for(e=this.currentToken();e&&t<e.tightness;){r=this.tokensByType[e.type],this.advance();let t=r.extendParse(this,s,e);if(t.range.start=s.range.start,t.range.end=this.charPosition(),t.type==d)return t;s=t,e=this.currentToken()}return s}}let m=0;function E(){m=0}class T{constructor(){this.startStates=[new A],this.acceptingStates=[]}newState(t){return new A(t)}markAccepting(t){-1==this.acceptingStates.indexOf(t)&&this.acceptingStates.push(t),t.addEdge(new P(t,null,[])),t.isAccepting=!0}markNonAccepting(t){t.isAccepting=!1,-1!=this.acceptingStates.indexOf(t)&&this.acceptingStates.splice(this.acceptingStates.indexOf(t),1)}getStates(){let t={},e=this.startStates.slice();for(;e.length;){const r=e.pop();t[r.id]=r;for(let n in r.edges){let s=r.edges[n];!s.target||s.target.id in t||e.push(s.target)}}return Object.keys(t).map(e=>t[e])}toDot(){return"digraph g {\n  rankdir=LR;\n"+this.getStates().map(function(t){return["  "+t.id+` [shape=${t.isAccepting?"doublecircle":"circle"}];`].concat(t.edges.map(function(e,r){return"  "+t.id+"->"+e.target.id+` [label="${r}:${e.formula?x(e.formula):"&#949;"}:${e.label.map(t=>t.type+"."+t.group).join(",")}"];`})).join("\n")}).join("\n")+"\n}"}eelim(){let t=this.startStates.slice(),e={};for(let r=0;r<t.length;r++)e[t[r].id]=t[r];for(;t.length;){const r=t.pop();let n={[r.id]:r};for(let t=0;t<r.edges.length;t++){const e=r.edges[t];if(!(e.formula||r.isAccepting&&e.target==r)){if(e.target.id in n){r.edges.splice(t,1),t--;continue}{const n=e.target.edges.map(t=>new P(t.target==e.target&&null==t.formula?r:t.target,t.formula,e.label.concat(t.label)));e.target.isAccepting&&!r.isAccepting&&(this.acceptingStates.push(r),r.isAccepting=!0),r.edges.splice(t,1,...n)}}n[e.target.id]=e.target}for(let r in n)r in e||(t.push(n[r]),e[r]=n[r])}return this}intersect(t){this.eelim();const e=this;t.eelim();let r=new T;r.startStates=[];let n=[],i={};for(let s=0;s<e.startStates.length;s++){const a=e.startStates[s];for(let e=0;e<t.startStates.length;e++){const s=t.startStates[e];n.push([a,s]),a.id in i||(i[a.id]={});let c=r.newState(`a${a.id}x${s.id}b`);r.startStates.push(c),i[a.id][s.id]=c,a.isAccepting&&s.isAccepting&&r.markAccepting(c)}}for(;n.length;){const[t,e]=n.pop(),o=i[t.id][e.id];for(let h=0;h<t.edges.length;h++){const u=t.edges[h],l=u.target,p=t.isAccepting&&l==t&&!u.formula;for(let t=0;t<e.edges.length;t++){const h=e.edges[t],d=h.target;let g=null;if(p!=(e.isAccepting&&d==e&&!h.formula))continue;if(!(p||(u.formula&&h.formula||console.error("Uneliminated non ASE epsilon transition"),a=u.formula,c=h.formula,g={type:s.AND,value:"&",children:[a,c],range:{start:-1,end:-1}})))continue;let f=null;l.id in i&&d.id in i[l.id]?f=i[l.id][d.id]:(f=r.newState(`a${l.id}x${d.id}b`),l.id in i||(i[l.id]={}),i[l.id][d.id]=f,n.push([l,d]),l.isAccepting&&d.isAccepting&&(f.isAccepting=!0,r.acceptingStates.push(f))),o.addEdge(new P(f,g,u.label.concat(h.label)))}}}var a,c;return r}}class A{constructor(t){this.id=t||(m++).toString(10),this.edges=[],this.isAccepting=!1}addEdge(t){this.edges.push(t)}removeEdge(t){this.edges.splice(this.edges.indexOf(t),1)}}class P{constructor(t,e,r){this.target=t,this.formula=e,this.label=r}}function v(t){const e=new T,r=function t(e,r,n){if(f(n)&&n.type!=s.CAPTURE){const t=new P(null,n,[]);return r.addEdge(t),[t]}if(n.type==s.CONCATENATION){const s=t(e,r,n.children[0]),i=e.newState();for(let t=0;t<s.length;t++){let e=s[t];e.target=i}return t(e,i,n.children[1])}if(n.type==s.REPETITION){const a=n.value.greedy,c=n.value.lowerBound,o=n.value.upperBound,h=n.children[0];if(c>0){let a=i(n);a.value.lowerBound--,"$END"!=a.value.upperBound&&a.value.upperBound--;let c={type:s.CONCATENATION,value:",",children:[i(h),a],range:{start:a.range.start,end:a.range.end}};return t(e,r,c)}if("$END"!=o){let c=i(n);c.value.upperBound--;let u={type:s.CONCATENATION,value:",",children:[i(h),c],range:{start:c.range.start,end:c.range.end}};if(a){let n=[];n=0==o?n.concat([new P(null,h,[])]):n.concat(t(e,r,u));const s=new P(null,null,[]);return r.addEdge(s),n.push(s),n}{let n=[];const s=new P(null,null,[]);return r.addEdge(s),n.push(s),n=1==o?n.concat([new P(null,h,[])]):n.concat(t(e,r,u))}}if(a){let n=t(e,r,h);for(let t=0;t<n.length;t++){let e=n[t];e.target=r}const s=new P(null,null,[]);return r.addEdge(s),[s]}{const n=new P(null,null,[]);r.addEdge(n);let s=t(e,r,h);for(let t=0;t<s.length;t++){let e=s[t];e.target=r}return[n]}}if(n.type==s.GROUP){let s=e.newState();r.addEdge(new P(s,null,[]));const i=t(e,s,n.children[0]);return i}if(n.type==s.CAPTURE){let s=e.newState(),i={type:"start-capture",group:"$implicit"==n.value.group?s.id:n.value.group};r.addEdge(new P(s,null,[i]));const a=t(e,s,n.children[0]);for(let t=0;t<a.length;t++){let e=a[t];e.label.push({type:"end-capture",group:"$implicit"==n.value.group?s.id:n.value.group,start:i})}return a}if(n.type==s.ALTERNATION){const s=e.newState(),i=e.newState();r.addEdge(new P(s,null,[])),r.addEdge(new P(i,null,[]));const a=t(e,s,n.children[0]),c=t(e,i,n.children[1]);return a.concat(c)}if(n.type==s.INTERSECTION){const t=v(n.children[0]),s=v(n.children[1]),i=t.intersect(s),a=i.acceptingStates.slice();for(let t=0;t<i.startStates.length;t++)r.addEdge(new P(i.startStates[t],null,[]));let c=[];for(let t=0;t<a.length;t++){const r=a[t];e.markNonAccepting(r);for(let t=0;t<r.edges.length;t++)r.edges[t].target!=r||r.edges[t].formula||(r.edges[t].target=null,c.push(r.edges[t]))}return c}throw"Not yet implemented"}(e,e.startStates[0],t),n=e.newState();for(let t=0;t<r.length;t++){r[t].target=n}return e.markAccepting(n),e}const R=!1;class I{constructor(t){this.captureIdx=0}compileTree(t,e){if(t.type==s.GROUP)return this.compileTree(t.children[0],e);if(t.type==s.CAPTURE){const r=this.captureIdx,n="$implicit"==t.value.group?r:t.value.group,s={type:"start",group:n,captureID:r,index:e,source:t};this.captureIdx++;const i=this.compileTree(t.children[0],e+1),a={type:"end",group:n,captureID:r,index:e+1+i.length,source:t};return[s].concat(i).concat([a])}if(f(t))return[{type:"check",formula:t,index:e,source:t}];if(t.type==s.CONCATENATION){const r=e,n=this.compileTree(t.children[0],r),s=e+n.length,i=this.compileTree(t.children[1],s);return n.concat(i)}if(t.type==s.ALTERNATION){const r=e+1,n=this.compileTree(t.children[0],r),s=r+n.length+1,i=[{type:"split",left:r,right:s,index:e,source:t}],a=this.compileTree(t.children[1],s),c=[{type:"jump",target:s+a.length,index:r+n.length,source:t}];return i.concat(n).concat(c).concat(a)}if(t.type==s.INTERSECTION){const r=v(t.children[0]),n=v(t.children[1]),s=r.intersect(n);return this.compileSFA(s,e)}if(t.type==s.REPETITION){const r=t.value.greedy,n=t.value.lowerBound,s=t.children[0];let i=[];for(let t=0;t<n;t++){const t=this.compileTree(s,e);e+=t.length,i.push(...t)}if(t.value.upperBound!=u){const a=t.value.upperBound;let c=[],o=[];for(let t=n;t<a;t++){e+=1,o.push(e);const t=this.compileTree(s,e);e+=t.length,c.push(t)}let h=[];for(let n=0;n<c.length;n++)h.push({type:"split",left:r?o[n]:e,right:r?e:o[n],index:o[n]-1,source:t}),h.push(...c[n]);return i.concat(h)}{const n=e,a=n+1,c=this.compileTree(s,a),o=[{type:"jump",target:n,index:a+c.length,source:t}],h=a+c.length+1,u=[{type:"split",left:r?a:h,right:r?h:a,index:e,source:t}];return i.concat(u).concat(c).concat(o)}}throw new Error("Can't compile "+JSON.stringify(t))}compileSFA(t,e){let r={},n=[],s=[];for(let i=0;i<t.startStates.length;i++){const a=t.startStates[i],c=this.compileSFA_(a,e,r,n);s=s.concat(c),e+=c.length}for(let t=0;t<n.length;t++)n[t].target=e;return s}compileSFA_(t,e,r,n){if(t.id in r)return[{type:"jump",target:r[t.id],index:e,source:{type:"state",value:t.id}}];if(r[t.id]=e,0==t.edges.length){if(t.isAccepting){const r={type:"jump",target:null,index:e,source:{type:"state",value:t.id,children:[],range:{start:-1,end:-1}}};return n.push(r),[r]}throw new Error("Compiling an SFA state with no outgoing edges")}{let s=[];for(let i=0;i<t.edges.length-1;i++){const a=t.edges[i],c={type:"split",left:e+1,right:null,index:e,source:{type:"state",value:`${t.id}.${i}`,children:[],range:{start:-1,end:-1}}},o=[c].concat(this.compileSFA_edge(t,a,e+1,r,n));s=s.concat(o),e+=o.length,c.right=e}const i=t.edges[t.edges.length-1],a=this.compileSFA_edge(t,i,e,r,n);return s.concat(a)}}compileSFA_edge(t,e,r,n,s){const i=this.compileSFA_edgeLabel(t,e,r);if(r+=i.length,t.isAccepting&&e.target==t&&!e.formula){const n={type:"jump",target:null,index:r,source:{type:"edge",value:`${t.id}->${e.target.id}`,children:[],range:{start:-1,end:-1}}};return s.push(n),i.concat([n])}return e.formula?i.concat([{type:"check",formula:e.formula,index:r,source:{type:"edge",value:`${t.id}->${e.target.id}`}}]).concat(this.compileSFA_(e.target,r+1,n,s)):i.concat(this.compileSFA_(e.target,r,n,s))}compileSFA_edgeLabel(t,e,r){let n=[];for(let s=0;s<e.label.length;s++){const i=e.label[s];if("start-capture"==i.type){const s=this.captureIdx,a=i.group;i.captureID=s;const c={type:"start",group:a,captureID:s,index:r,source:{type:"edge",value:`${t.id}->${e.target.id}`,children:[],range:{start:-1,end:-1}}};this.captureIdx++,n.push(c),r++}else if("end-capture"==i.type){const s=i.start.captureID,a={type:"end",group:i.group,captureID:s,index:r,source:{type:"edge",value:`${t.id}->${e.target.id}`,children:[],range:{start:-1,end:-1}}};n.push(a),r++}}return n}compile(t,e=!1){if(!this.validateParseTree(t))throw new Error("Parse tree did not represent a valid program");E(),this.captureIdx=0;const r=[{type:"split",left:3,right:1,index:0,source:"root"},{type:"check",formula:{type:s.TRUE,value:!0,children:[],range:{start:0,end:0}},index:1,source:"root"},{type:"jump",target:0,index:2,source:"root"},{type:"start",group:"$root",captureID:-1,index:3,source:"root"}],n=this.compileTree(t,r.length),i=r.concat(n).concat([{type:"end",group:"$root",captureID:-1,index:r.length+n.length,source:"root"},{type:"match",index:r.length+n.length+1,source:"root"}]);if(!this.validateProgram(i))throw new Error("Error compiling tree "+JSON.stringify(t)+" into result "+JSON.stringify(i));if(!e)for(let t=0;t<i.length;t++)delete i[t].source,delete i[t].index;return i}validateParseTree(t){return!R||!this.anyCapturesInsidePropositions(t)}anyCapturesInsidePropositions(t){const e=f(t);for(let r=0;r<t.children.length;r++){const n=t.children[r];if(e&&n.type==s.CAPTURE)return console.log(`Can't put a capturing group inside of a propositional term: ${x(t)}!`),!0;if(this.anyCapturesInsidePropositions(n))return!0}return!1}validateProgram(t){if(!R)return!0;for(let e=0;e<t.length;e++){const r=t[e];if(r.index!==e)throw new Error(`Bad code generation:${r.index} != ${e} for ${S([r])} in ${S(t)}`)}const e=this.reachableInstructions(t,0,{});for(let r=0;r<t.length;r++)if(!e[r])throw new Error(`Bad code generation:${r} not reachable for ${S([t[r]])} in ${S(t)}`);return!0}reachableInstructions(t,e,r){if(e in r||e>=t.length)return r;r[e]=!0;const n=t[e];if("split"==n.type){let e=this.reachableInstructions(t,n.left,r);return this.reachableInstructions(t,n.right,e)}return"jump"==n.type?this.reachableInstructions(t,n.target,r):this.reachableInstructions(t,e+1,r)}}function N(t){const e=void 0===t.value?"":t.value.toString(),r=t.children&&t.children.length?t.children.map(t=>x(t)).join(","):"";return`${t.type}(${e},${r})`}function x(t){switch(t.type){case s.TRUE:return"true";case s.FALSE:return"false";case s.START:return"start";case s.END:return"end";case s.AND:return`${x(t.children[0])} & ${x(t.children[1])}`;case s.OR:return`${x(t.children[0])} | ${x(t.children[1])}`;case s.NOT:return`not ${x(t.children[0])}`;case s.GROUP:return`(${x(t.children[0])})`;case s.CAPTURE:return`$${t.value.captureID}:${t.value.group}(${x(t.children[0])})`;default:return N(t)}}function S(t){let e=[];for(let n=0;n<t.length;n++){const s=t[n];let i=`${n}:${s.type}`;switch(s.type){case"split":i+=` ${s.left} ${s.right}`;break;case"jump":i+=` ${s.target}`;break;case"check":i+=" "+x(s.formula);break;case"start":case"end":i+=` ${s.group} (${s.captureID})`;break;case"match":break;default:throw new Error("Unrecognized instruction "+s)}if(s.source){var r=s.source;"root"==r?i+="  \t\t(root)":"check"==s.type&&"range"in r?i+=`\t(ch. ${r.range.start}-${r.range.end})`:i+=`\t\t(${r.type} ${JSON.stringify(r.value)})`}e.push(i)}return e.join("\n")}class w{constructor(t,e,r=!1){this.context=e,this.spec=t;const n=new y(e.tokens),s=new I(e.tokens);if(this.parseResult=n.parse(t),this.parseResult.errors.length)throw new Error("Parsed with errors:"+JSON.stringify(this.parseResult.errors));this.program=s.compile(this.parseResult.tree,r)}get traceAPI(){return this.context.trace}get checkAPI(){return this.context.checks}check(t,e,r,n){var i,a;switch(n.type){case s.TRUE:return!0;case s.FALSE:return!1;case s.START:return 0==r;case s.END:return this.traceAPI.isAtEnd(t);case s.AND:return i=this.check(t,e,r,n.children[0]),a=this.check(t,e,r,n.children[1]),!(!i||!a)&&{node:n,left:i,right:a};case s.OR:return i=this.check(t,e,r,n.children[0]),a=this.check(t,e,r,n.children[1]),!(!i&&!a)&&{node:n,left:i,right:a};case s.NOT:return!this.check(t,e,r,n.children[0]);case s.GROUP:return this.check(t,e,r,n.children[0]);default:if(this.checkAPI[n.type])return this.checkAPI[n.type](t,e,r,n);throw new Error("Unrecognized propositional formula")}}match(t,e=!1){return new F({spec:this,preserveStates:e},function(t){return{queue:new _,nextQueue:new _,threads:[],liveSet:new k((t,e)=>t==e,t=>t),maxThreadID:0,index:-1,pastEnd:!1,trace:t,matchQueue:new U(t=>t.priority),matchSet:new k(b,D),lastMatchPriority:0}}(t),void 0).next()}}class O{constructor(t,e,r,n){this.id=t,this.pc=e,this.priority=r,this.matches=n.map(function(t){let e=C(t);return e.priority=Math.max(r,t.priority),e})}equals(t){return this.pc==t.pc}hash(){return this.pc}mergeThread(t){for(let e=0;e<t.matches.length;e++){let r=!1;for(let n=0;n<this.matches.length;n++)if(b(this.matches[n],t.matches[e])){r=!0;break}if(!r){let r=C(t.matches[e]);r.priority=Math.max(this.priority,r.priority),this.matches.push(r)}}}hasOpenMatch(){for(let t=0;t<this.matches.length;t++)if(this.matches[t].instructions.length>0)return!0;return!1}hasExplicitMatch(){for(let t=0;t<this.matches.length;t++)if(this.matches[t].instructions.length>0&&-1!=this.matches[t].instructions[0].groupIndex)return!0;return!1}pushMatchInstruction(t){for(let e=0;e<this.matches.length;e++)this.matches[e].instructions.push(t)}terminate(){this.matches=[]}}class k{constructor(t,e,r=1e3){this.equiv=t,this.hash=e,this.coll=new Array(r),this.length=0}bucketFind(t,e){for(let r=0;r<t.length;r++)if(this.equiv?this.equiv(t[r].key,e):t[r].key==e)return t[r].val}push(t,e){const r=this.hash(t)%this.coll.length;let n=this.coll[r];if(n){if(void 0!==this.bucketFind(n,t))return!1;n.push({key:t,val:e})}else this.coll[r]=[{key:t,val:e}];return this.length++,!0}get(t){if(0==this.length)return;const e=this.hash(t)%this.coll.length;let r=this.coll[e];return r?this.bucketFind(r,t):void 0}clear(){for(let t=0;t<this.coll.length;t++)this.coll[t]=[];this.length=0}contains(t){if(0==this.length)return!1;const e=this.hash(t)%this.coll.length;let r=this.coll[e];return!!r&&void 0!==this.bucketFind(r,t)}}function $(t,e){return t+=0|e,t+=t<<10|0,t^=t>>6|0,t+=e>>8|0,t+=t<<10|0,t^=t>>6|0,t+=e>>16|0,t+=t<<10|0,t^=t>>6|0,t+=e>>24|0,t+=t<<10|0,t^=t>>6|0}const b=function(t,e){if(t.instructions.length!=e.instructions.length)return!1;for(let r=0;r<t.instructions.length;r++){const n=t.instructions[r],s=e.instructions[r];if(n.type!=s.type||n.index!=s.index||n.group!=s.group)return!1}return!0},D=function(t){return function(...t){let e=0;for(let r=0;r<t.length;r++)e=$(e,t[r]);return function(t){return t+=t<<3|0,t^=t>>11|0,t+=t<<15|0}(e)}(t.instructions.length)};function C(t){return{priority:t.priority,instructions:t.instructions.slice()}}class _{constructor(){this.array=[],this.length=0}push(t){this.array[this.length]=t,this.length++}clear(){this.length=0}get first(){if(0!=this.length)return this.array[0]}get(t){if(!(t<0||t>=this.length))return this.array[t]}}class U{constructor(t,e,r){this.queues=[],this.priorityFunction=t,this.length=0,this.lowestPriority=1/0,this.highestPriority=-1/0,this.members=e&&r?new k(e,r):void 0,this.clear()}push(t){const e=this.priorityFunction(t);if(this.members){if(this.members.contains(t))return!1;this.members.push(t,!0)}return e in this.queues?this.queues[e].push(t):this.queues[e]=[t],e<this.lowestPriority&&(this.lowestPriority=e),e>this.highestPriority&&(this.highestPriority=e),this.length++,!0}shift(){if(this.lowestPriority>=1/0||0==this.length)return;const t=this.queues[this.lowestPriority],e=t.pop();if(0==t.length)if(delete this.queues[this.lowestPriority],this.highestPriority<=this.lowestPriority)this.lowestPriority=1/0,this.highestPriority=-1/0;else for(;!this.queues[this.lowestPriority]&&this.lowestPriority<this.highestPriority;)this.lowestPriority++;return this.length--,e}get first(){if(0!=this.length)return this.queues[this.lowestPriority][0]}clear(){this.queues=[],this.lowestPriority=1/0,this.highestPriority=-1/0,this.length=0,this.members&&this.members.clear()}}const q=100;class F{constructor(t,e,r){if(this.config=t,this.state=e,-1==this.state.index){this.state.trace=this.config.spec.traceAPI.start(this.state.trace);let t=new O(0,0,0,[{priority:0,instructions:[]}]);this.enqueueThread(t);const e=this.state.queue;this.state.queue=this.state.nextQueue,this.state.nextQueue=e,this.state.liveSet.clear(),this.state.matchSet.clear(),this.state.index=0}this.match=r}get start(){return this.match?this.match.start:-1}get end(){return this.match?this.match.end:-1}get states(){return this.match?this.match.states:void 0}get subgroups(){return this.match?this.match.subgroups:void 0}hasReadyMatch(){return!!this.state.matchQueue.length&&(!this.state.queue.length||this.state.matchQueue.first.priority<=this.state.queue.first.priority)}enqueueThread(t){const e=this.config.spec.program[t.pc];switch(e.type){case"jump":return t.pc=e.target,void this.enqueueThread(t);case"split":this.state.maxThreadID++,t.pc=e.left;const r=new O(this.state.maxThreadID,e.right,t.priority+1,t.matches);return this.enqueueThread(t),void this.enqueueThread(r);case"start":return t.pushMatchInstruction({type:"start",index:this.state.index+1,group:e.group,groupIndex:e.captureID}),t.pc++,void this.enqueueThread(t);case"end":return t.pushMatchInstruction({type:"end",index:this.state.index+1,group:e.group,groupIndex:e.captureID}),t.pc++,void this.enqueueThread(t);case"match":for(let e=0;e<t.matches.length;e++)t.matches[e].priority>=t.priority&&this.state.matchSet.push(t.matches[e],!0)&&this.state.matchQueue.push(t.matches[e]);return void t.terminate();case"check":const n=t.hash();let s=this.state,i=s.liveSet.get(n);if(i){if(i.index!=s.index)i.index=s.index,i.threads.clear(),i.threads.push(t);else for(let e=0;e<i.threads.length;e++)if(i.threads.get(e).equals(t))return i.threads.get(e).mergeThread(t),void t.terminate()}else{let e=new _;e.push(t),s.liveSet.push(n,{index:s.index,threads:e})}return void s.nextQueue.push(t);default:throw new Error("Unrecognized instruction type ${instr.type}")}}prettifyMatch(t){let e=[],r={};for(let n=0;n<t.instructions.length;n++){const s=t.instructions[n];switch(s.type){case"start":let t={group:s.group,groupIndex:s.groupIndex,start:s.index,end:1/0,states:void 0,results:void 0};if(this.config.preserveStates&&(t.states=[],t.results=[]),e.push(t),r[t.group])throw new Error("Duplicate capture group");r[t.group]=t;break;case"state":let n=Object.getOwnPropertyNames(r);for(let t=0;t<n.length;t++){let e=r[n[t]];e.states.push(s.state),e.results.push(s.result)}break;case"end":r[s.group].end=s.index,delete r[s.group]}}let n=Object.getOwnPropertyNames(r);if(n.length)throw new Error(`Open capture groups: ${n.join(",")}`);let s=e.shift(),i={start:s.start,end:s.end,subgroups:e.filter(t=>t.start!=t.end),states:void 0,results:void 0};return this.config.preserveStates&&(i.states=s.states,i.results=s.results),i}next(){if(!this.state)throw new Error("Don't call next() on the same PlayspecResult twice!");if(!this.hasReadyMatch()&&this.config.spec.traceAPI.isReady&&!this.config.spec.traceAPI.isReady(this.state.trace)){const t=this.state;return this.state=void 0,new F(this.config,t,void 0)}for(;!this.hasReadyMatch()&&this.state.queue.length;){const t=this.config.spec.traceAPI.currentState(this.state.trace);let e=void 0;const r=this.state.queue.length;let n=0;for(let s=0;s<this.state.queue.length;s++){if(s>=r)throw new Error("The thread queue should never grow during a single trace state!");let i=this.state.queue.get(s);if(i.priority<n)throw new Error("Decreasing priority!");const a=this.config.spec.program[i.pc];switch(a.type){case"check":const r=this.config.spec.check(this.state.trace,t,this.state.index,a.formula);r?(i.pc++,i.hasOpenMatch()&&this.config.preserveStates&&(i.hasExplicitMatch()||"explicit"!=this.config.preserveStates)&&(e||(e=this.config.spec.traceAPI.copyCurrentState?this.config.spec.traceAPI.copyCurrentState(this.state.trace):t),i.pushMatchInstruction({type:"state",index:this.state.index,state:e,result:r})),this.enqueueThread(i)):i.terminate();break;default:throw new Error("Thread should be parked on a check.")}}let s=this.state.queue;if(this.state.queue=this.state.nextQueue,s.clear(),this.state.nextQueue=s,this.state.index%q==0&&this.state.liveSet.clear(),this.state.matchSet.clear(),this.config.spec.traceAPI.isAtEnd(this.state.trace)){this.config.spec.traceAPI.isStreaming&&this.config.spec.traceAPI.isStreaming(this.state.trace)||this.state.queue.clear();break}this.config.spec.traceAPI.advanceState(this.state.trace),this.state.index++}if(this.hasReadyMatch()){const t=this.state.matchQueue.shift();if(this.state.lastMatchPriority>t.priority)throw new Error("Matches popped out of order!");this.state.lastMatchPriority=t.priority;const e=this.prettifyMatch(t),r=this.state;return this.state=void 0,new F(this.config,r,e)}if(this.config.spec.traceAPI.isStreaming&&this.config.spec.traceAPI.isStreaming(this.state.trace)){const t=this.state;return this.state=void 0,new F(this.config,t,void 0)}return this.state=void 0,null}}r.d(e,"tokenTypes",function(){return n}),r.d(e,"parseTypes",function(){return s}),r.d(e,"cloneTree",function(){return i}),r.d(e,"constantValue",function(){return a}),r.d(e,"parseValue",function(){return c}),r.d(e,"parseInfixR",function(){return o}),r.d(e,"parseInfixRPropositional",function(){return h}),r.d(e,"BOUND_INFINITE",function(){return u}),r.d(e,"standardTokens",function(){return l}),r.d(e,"isCustom",function(){return g}),r.d(e,"isPropositional",function(){return f}),r.d(e,"Parser",function(){return y}),r.d(e,"Compiler",function(){return I}),r.d(e,"stringifyCustom",function(){return N}),r.d(e,"stringifyFormula",function(){return x}),r.d(e,"stringify",function(){return S}),r.d(e,"Playspec",function(){return w}),r.d(e,"SFA",function(){return T}),r.d(e,"fromParseTree",function(){return v}),r.d(e,"resetStateID",function(){return E})}]);
//# sourceMappingURL=bundle.js.map