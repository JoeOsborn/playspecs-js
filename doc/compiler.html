<html>
<head>
    <link rel="stylesheet" href="resources/css/explain.css"/>
    <script src="resources/js/explain.js"></script>
    <script src="../playspecs.js"></script>
</head>
<body>
<h1>Compilation</h1>

<p>Compilation and interpretation of Playspecs follows the general pattern of the Thompson/Pike VM, quite clearly
    described by <a href="https://swtch.com/~rsc/regexp/regexp2.html">Russ Cox</a>. Briefly, the parse tree is compiled
    into virtual machine instructions which are then <a href="interpreter.html">interpreted</a>. In this document, we
    will start by addressing the basics of compilation, then show how custom predicates are incorporated. Finally we
    explore the addition of advanced features like subgroup matching and intersection.</p>

<p>The VM is primarily a thread scheduler, where a thread is something like a single NFA state; for now, imagine that
    each thread is defined simply by a program counter. Alternations and repetition spawn new threads (if equivalent
    threads do not yet exist), and all threads are advanced in lockstep. Threads are synchronized on
    <code class="bytecode">check Phi</code> instructions; other instructions roughly correspond to null transitions and
    are executed as far as possible until reaching <code class="bytecode">check</code> or
    <code class="bytecode">match</code> instructions. The result is that the number of trips through the thread queue is
    bounded by the length of the play trace being matched.</p>

<p>We start with "simple Playspecs", i.e. we ignore intersection for now. The core instructions are
    <code class="bytecode">check Phi</code> (where <code class="bytecode">Phi</code> is a propositional formula),
    <code class="bytecode">jump Target</code> (where <code class="bytecode">Target</code> is an integer describing the
    unconditional jump destination), <code class="bytecode">split Left Right</code> (where both arguments are integers
    describing program counter values), and <code class="bytecode">match</code> which indicates a thread has
    successfully matched. The compilation strategy is detailed in the table below.</p>

<table>
    <tr>
        <td>Formula</td>
        <td>VM Instructions</td>
    </tr>
    <tr>
        <td>Propositional formula <code>F</code></td>
        <td><code class="bytecode">check F</code></td>
    </tr>
    <tr>
        <td><code>A,B</code></td>
        <td>instructions for <code>A</code><br/>
            instructions for <code>B</code></td>
    </tr>
    <tr>
        <td><code>A;B</code></td>
        <td><code class="bytecode">split lA, lB</code><br/>
            <code class="bytecode">lA</code>: instructions for <code>A</code><br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <code class="bytecode">jump lC</code><br/>
            <code class="bytecode">lB</code>: instructions for <code>B</code><br/>
            <code class="bytecode">lC</code>: (next)
        </td>
    </tr>
    <tr>
        <td><code>A M...N</code></td>
        <td>
            <code>M</code> repetitions of instructions for <code>A</code><br/>
            For each <code>i</code> from 1 to <code>M-N</code>, repeat:<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <code class="bytecode">split li,lZ</code><br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <code class="bytecode">li</code>: instructions for <code>A</code><br/>
            <code class="bytecode">lZ</code>: (next)
        </td>
    </tr>
    <tr>
        <td><code>A M...</code></td>
        <td>
            <code>M</code> repetitions of instructions for <code>A</code><br/>
            <code class="bytecode">lA</code>: <code class="bytecode">split lB, lC</code><br/>
            <code class="bytecode">lB</code>: instructions for <code>A</code><br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <code class="bytecode">jump lA</code><br/>
            <code class="bytecode">lC</code>: (next)
        </td>
    </tr>
    <tr>
        <td><code>A M..N</code></td>
        <td>
            As per <code>A M...N</code>, but instead <code class="bytecode">split lZ, li</code>
        </td>
    </tr>
    <tr>
        <td><code>A M..</code></td>
        <td>
            As per <code>A M...</code>, but instead <code class="bytecode">split lC, lB</code>
        </td>
    </tr>
    <tr>
        <td>(end of Playspec)</td>
        <td><code class="bytecode">match</code></td>
    </tr>
</table>

<script>
    var promWeek = {
        tokens: [
            {
                type: "PERSON",
                match: ["Chloe", "Simon", "Phoebe", "Doug"/*, ... */],
                startParse: Playspecs.Parser.parseValue
            },
            {
                type: "RELATIONSHIP",
                match: ["dating", "friends", "enemies", "embarrassed"/*, ... */],
                startParse: Playspecs.Parser.parseValue
            },
            {
                type: "LINK",
                match: "-",
                // Custom tokens have their own precedence scale and always bind tighter than built-in ones.
                tightness: 1,
                extendParse: function (parser, parseTree, token) {
                    var left = parseTree;
                    if (left.type != "PERSON") {
                        return parser.error("Left hand side of LINK must be PERSON", token, parseTree);
                    }
                    // Links are not associative, so we must parse at a higher tightness.
                    // In other words, this call to parseExpression will never try to extend the given parse
                    // using a LINK or any lower-precedence term.
                    var relationship = parser.parseExpression(token.tightness);
                    // A real implementation would handle inequalities over network values too.
                    if (relationship.type != "RELATIONSHIP") {
                        return parser.error("Middle term of LINK must be RELATIONSHIP", token, relationship);
                    }
                    // We need to examine the next token without running parseExpression again to know if the
                    // LINK syntax is being used correctly.
                    var current = parser.currentToken();
                    if (current.type != "LINK") {
                        return parser.error(
                                "A second LINK token must appear after the middle term of a LINK",
                                current
                        );
                    }
                    parser.advance();
                    var right = parser.parseExpression(token.tightness + 1);
                    if (right.type != "PERSON") {
                        return parser.error("Right hand side of LINK must be PERSON", token, right);
                    }
                    // We'll keep all three parse trees around to maintain location information, etc.
                    return parser.node("LINK_RELATIONSHIP", undefined, [left, relationship, right]);
                }
            }
            // Also: networks, inequalities, numbers
        ]
    };
    var expectedStringProgram =
            "0:split 2 1\n" +
            "1:check true\n" +
            "2:jump 0\n" +
            "3:check start\n" +
            "4:split 5 7\n" +
            "5:check not LINK_RELATIONSHIP(,PERSON(Chloe,),RELATIONSHIP(dating,),PERSON(Doug,))\n" +
            "6:jump 4\n" +
            "7:check LINK_RELATIONSHIP(,PERSON(Doug,),RELATIONSHIP(embarrassed,),PERSON(Chloe,)) & end\n" +
            "8:match";
    desc("<p>First, we should compile a simple Playspec. While in practice the <code>Playspecs</code> module is " +
            "the most convenient way to construct Playspecs, here we want to illustrate <code>Compiler</code>'s " +
            "behavior so we use it directly. Its input is a <code>ParseTree</code> from the <code>Parser</code> " +
            "module. The game-specific context configuration object is passed to both; here, we use the Prom Week " +
            "example from the <a href='parser.html'><code>Parser</code> documentation</a>. Note that the output " +
            "program has some additional front matter; every Playspec is implicitly anchored to <code>start</code> " +
            "as if prefixed by the reluctant repetition <code>..</code>, so that one linear check over the string " +
            "always suffices to find all matches (as per <a href='https://swtch.com/~rsc/regexp/regexp2.html'>Russ " +
            "Cox's note on unanchored expressions</a>).</p>", function () {
        var parser = new Playspecs.Parser.Parser(promWeek);
        var compiler = new Playspecs.Compiler.Compiler(promWeek);
        var parseTree = parser.parse("start, not Chloe-dating-Doug ..., Doug-embarrassed-Chloe & end").tree;
        var program = compiler.compile(parseTree);
        ex(program, [
            {
                "type": "split",
                "left": 2,
                "right": 1,
                "index": 0
            },
            {
                "type": "check",
                "formula": {
                    "type": "true",
                    "value": true,
                    "children": [],
                    "range": {
                        "start": 0,
                        "end": 0
                    }
                },
                "index": 1
            },
            {
                "type": "jump",
                "target": 0,
                "index": 2
            },
            {
                "type": "check",
                "formula": {
                    "type": "start",
                    "value": "start",
                    "children": [],
                    "range": {
                        "start": 0,
                        "end": 5
                    }
                },
                "index": 3
            },
            {
                "type": "split",
                "left": 5,
                "right": 7,
                "index": 4
            },
            {
                "type": "check",
                "formula": {
                    "type": "not",
                    "value": "not",
                    "children": [
                        {
                            "type": "LINK_RELATIONSHIP",
                            "children": [
                                {
                                    "type": "PERSON",
                                    "value": "Chloe",
                                    "children": [],
                                    "range": {
                                        "start": 11,
                                        "end": 16
                                    }
                                },
                                {
                                    "type": "RELATIONSHIP",
                                    "value": "dating",
                                    "children": [],
                                    "range": {
                                        "start": 17,
                                        "end": 23
                                    }
                                },
                                {
                                    "type": "PERSON",
                                    "value": "Doug",
                                    "children": [],
                                    "range": {
                                        "start": 24,
                                        "end": 29
                                    }
                                }
                            ],
                            "range": {
                                "start": 11,
                                "end": 29
                            }
                        }
                    ],
                    "range": {
                        "start": 7,
                        "end": 29
                    }
                },
                "index": 5
            },
            {
                "type": "jump",
                "target": 4,
                "index": 6
            },
            {
                "type": "check",
                "formula": {
                    "type": "&",
                    "value": "&",
                    "children": [
                        {
                            "type": "LINK_RELATIONSHIP",
                            "children": [
                                {
                                    "type": "PERSON",
                                    "value": "Doug",
                                    "children": [],
                                    "range": {
                                        "start": 34,
                                        "end": 38
                                    }
                                },
                                {
                                    "type": "RELATIONSHIP",
                                    "value": "embarrassed",
                                    "children": [],
                                    "range": {
                                        "start": 39,
                                        "end": 50
                                    }
                                },
                                {
                                    "type": "PERSON",
                                    "value": "Chloe",
                                    "children": [],
                                    "range": {
                                        "start": 51,
                                        "end": 57
                                    }
                                }
                            ],
                            "range": {
                                "start": 34,
                                "end": 57
                            }
                        },
                        {
                            "type": "end",
                            "value": "end",
                            "children": [],
                            "range": {
                                "start": 59,
                                "end": 62
                            }
                        }
                    ],
                    "range": {
                        "start": 34,
                        "end": 62
                    }
                },
                "index": 7
            },
            {
                "type": "match",
                "index": 8
            }
        ]);
        // We can also ask the compiler to stringify the VM code for easier reading.
        var stringProgram = compiler.stringify(program);
        ex(stringProgram, expectedStringProgram);
    });
    var parser = new Playspecs.Parser.Parser(promWeek);
    var compiler = new Playspecs.Compiler.Compiler(promWeek);
    expectedStringProgram = "0:split 2 1  \t\t(root)\n" +
            "1:check true  \t\t(root)\n" +
            "2:jump 0  \t\t(root)\n" +
            "3:check true\t(ch. 0-0)\n" +
            "4:check true\t(ch. 0-0)\n" +
            "5:check true\t(ch. 0-0)\n" +
            "6:split 7 10\t\t(... {\"greedy\":true,\"lowerBound\":3,\"upperBound\":5})\n" +
            "7:check true\t(ch. 0-0)\n" +
            "8:split 9 10\t\t(... {\"greedy\":true,\"lowerBound\":3,\"upperBound\":5})\n" +
            "9:check true\t(ch. 0-0)\n" +
            "10:split 11 21\t\t(... {\"greedy\":true,\"lowerBound\":0,\"upperBound\":\"$END\"})\n" +
            "11:split 12 17\t\t(; \";\")\n" +
            "12:split 16 13\t\t(... {\"greedy\":false,\"lowerBound\":0,\"upperBound\":2})\n" +
            "13:check false\t(ch. 8-14)\n" +
            "14:split 16 15\t\t(... {\"greedy\":false,\"lowerBound\":0,\"upperBound\":2})\n" +
            "15:check false\t(ch. 8-14)\n" +
            "16:jump 20\t\t(; \";\")\n" +
            "17:check true\t(ch. 20-24)\n" +
            "18:check false\t(ch. 26-31)\n" +
            "19:check true\t(ch. 33-37)\n" +
            "20:jump 10\t\t(... {\"greedy\":true,\"lowerBound\":0,\"upperBound\":\"$END\"})\n" +
            "21:match  \t\t(root)";
    desc("<p>The gadgets all work as defined in the table above. For complicated programs, it may help understanding " +
            "to pass the <code>debug=true</code> flag to <code>compile()</code>, which maintains per-instruction " +
            "source information. <code>stringify</code> will annotate lines with such information. Control flow " +
            "instructions will be labeled with the control statement they belong to, while boolean checks will " +
            "be labeled with the character range where the condition appears in the original spec.</p>", function () {
        var parseTree = parser.parse("3...5, (false ..2 ; true, false, true) ...").tree;
        var program = compiler.compile(parseTree, true);
        var stringProgram = compiler.stringify(program);
        ex(stringProgram, expectedStringProgram);
    });
</script>

<h1>Interpretation</h1>

<p>For the purposes of this document, we'll introduce another domain for Playspecs: a hypothetical game whose moves are
    all represented by single upper- and lowercase letters. Reasonable questions to ask about states of this game
    include whether a particular letter describes the state or whether the letter is uppercase. In practice, if a
    game's traces can be defined so simply then conventional string regular expressions should serve the role of
    Playspecs quite well! But we will work from this simple case for now so that the semantics of the interpreter are
    easier to explain without bringing in too many details from a "real" game.</p>

<h2>The letters domain</h2>
<script>
    var lettersContext = {
        tokens: [
            {
                type: "LETTER",
                match: /^[a-z](?![a-z])/,
                startParse: Playspecs.Parser.parseValue
            },
            {
                type: "UPPER",
                match: "upper",
                startParse: Playspecs.Parser.parseValue
            }
        ],
        trace: {
            start: function(traceData) {
                return {data:traceData, index:0};
            },
            currentState: function(trace) {
                return trace.data[trace.index];
            },
            advanceState: function(trace) {
                if(trace.index < trace.data.length) {
                    trace.index++;
                }
            },
            isAtEnd: function(trace) {
                return trace.index >= trace.data.length;
            }
        },
        checks: {
            LETTER: function(_trace, state, letterNode) {
                return letterNode.value == state.toLowerCase();
            },
            UPPER: function(_trace, state, _letterNode) {
                return state.toUpperCase() == state;
            }
        }
    };
    desc("<p>The tokens of the <code>lettersContext</code> only come in two types, and both are values. For an " +
            "example Playspec, consider <code>start, a & upper, (b;c) ...</code> for any letter, then an uppercase " +
            "<code>a</code>, then a sequence of upper- and lowercase <code>b</code>s and <code>c</code>s. Note that " +
            "the character-checking formulae accept both upper- and lowercase letters, and <code>upper</code> must " +
            "be used to distinguish them.</p>");
    desc("<p>Next, we must introduce additional features of the game-specify context object. Specifically, we need " +
            "to define what a trace is and how the interpreter can read it. In the letters domain, we can use a " +
            "string to represent the whole trace. Assuming that a Playspec is executed against some generic " +
            "<code>traceData</code> object (a string in this case), the context must provide at least these four " +
            "functions for progressing through the trace:</p>", function() {
        ex(lettersContext.trace);
    });
    desc("<p>The interpreter first calls <code>start</code> on its argument to get a kind of iterator for the " +
            "<code>trace</code>. Then, until <code>isAtEnd</code> returns a truthy value, the interpreter repeatedly " +
            "checks <code>currentState</code> against all threads and then calls <code>advanceState</code>. In " +
            "the letters domain, we return the letter as our state; but we could just as well return the character " +
            "index and let the formula-checking functions get the character from the underlying string.</p>");
    desc("<p>Finally, we must give a way to define the meaning of terms like <code>UPPER</code> (or, in the case of " +
            "Prom Week, <code>LINK_RELATIONSHIP</code>). Since multiple token types may be parsed into one formula " +
            "type, and one token type could parse into several different types of formula, we require that games " +
            "provide a separate map from formula types to \"check functions\" which take the current trace, current " +
            "game state, and a parse tree as arguments, and return a boolean indicating whether the condition is " +
            "met. In the letters domain, the token types and formula types line up, but this is not true in general." +
            "</p>", function() {
        ex(lettersContext.checks);
    });
</script>

<h2>Simple Playspecs</h2>

general flow

greedy vs reluctant and match ordering

<p>Adding new features to this Playspecs implementation mainly involves devising new parse tokens and gadgets, sometimes
    requiring new VM instructions and occasionally new bits of thread state.</p>


<h2>Intersection</h2>

<h2>Subgroup Matching</h2>

</body>
</html>