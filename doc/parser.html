<html>
<head>
    <link rel="stylesheet" href="resources/css/explain.css"/>
    <script src="resources/js/explain.js"></script>
    <script src="../playspecs.js"></script>
</head>
<body>
<h1>Playspecs Parser</h1>

<p>The Playspecs parser is a top-down operator precedence parser, also called a
    <a href="http://dl.acm.org/citation.cfm?id=512931">Pratt parser</a>. Modern writeups of the technique include
    <a href="http://javascript.crockford.com/tdop/tdop.html">Doug Crockford's</a> article and
    <a href="http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing">Eli Bendersky's</a>
    readable summary of <a href="http://effbot.org/zone/simple-top-down-parsing.htm">Lundh's Python parser</a>.</p>

<h2>Tokenization</h2>

<p>Parsing begins with tokenization. The input string is transformed into a token stream and then the tokens drive the
    recursive descent stage. The Playspecs parser recognizes both the temporal and propositional fragments of the
    game-independent Playspecs syntax, and can tokenize certain simple specs on its own (this core syntax is defined in
    <a href="resources/paper.pdf">the AIIDE paper</a>). Whitespace is ignored except as it separates other tokens.</p>
<script>
    var expectedTokens = {
        "string": "start, ..., end",
        "tokens": [
            {
                "type": "start",
                "value": "start",
                "tightness": 0,
                "range": {
                    "start": 0,
                    "end": 5
                }
            },
            {
                "type": ",",
                "value": ",",
                "tightness": 100,
                "range": {
                    "start": 5,
                    "end": 6
                }
            },
            {
                "type": "...",
                "value": {
                    "greedy": true,
                    "lowerBound": 0,
                    "upperBound": "$END"
                },
                "tightness": 110,
                "range": {
                    "start": 7,
                    "end": 10
                }
            },
            {
                "type": ",",
                "value": ",",
                "tightness": 100,
                "range": {
                    "start": 10,
                    "end": 11
                }
            },
            {
                "type": "end",
                "value": "end",
                "tightness": 0,
                "range": {
                    "start": 12,
                    "end": 15
                }
            }
        ],
        "position": 0,
        "errors": []
    };
    desc("<p>Parsers are initialized with a context object, explained in the next paragraph. Tokenize returns a " +
            "kind of token stream with a list of tokens and a position index into that list, along with the original " +
            "string in case the eventual parse doesn't use up the whole string.</p>", function () {
        var parser = new Playspecs.Parser.Parser({});
        var tokens = parser.tokenize("start, ..., end");
        /*The result should look like this:
         var expectedTokens = {
         string: "start, ..., end",
         tokens: [
         {
         // `type` is the kind of Token this is. It is duplicated from the definition for convenience.
         type: Playspecs.Parser.tokenTypes.START,
         // `value` is its value; for symbols like `start` it's just the string itself.
         // For e.g. numbers, the value might be the Number represented by the string.
         value: "start",
         // `tightness` is duplicated from the token definition.
         tightness: 0,
         // `range` is where this token's first and last characters appear in the string.
         range: {start: 0, end: 5}
         },
         ... more tokens ...
         ],
         position: 0,
         errors: []
         };
         */
        ex(tokens, expectedTokens);
    });
    expectedTokens = {
        "string": "start bad , -> end",
        "tokens": [
            {
                "type": "start",
                "value": "start",
                "tightness": 0,
                "range": {
                    "start": 0,
                    "end": 5
                }
            },
            {
                "type": "error",
                "value": "bad",
                "tightness": 0,
                "range": {
                    "start": 6,
                    "end": 9
                }
            },
            {
                "type": ",",
                "value": ",",
                "tightness": 100,
                "range": {
                    "start": 10,
                    "end": 11
                }
            },
            {
                "type": "error",
                "value": "->",
                "tightness": 0,
                "range": {
                    "start": 12,
                    "end": 14
                }
            },
            {
                "type": "end",
                "value": "end",
                "tightness": 0,
                "range": {
                    "start": 15,
                    "end": 18
                }
            }
        ],
        "position": 0,
        "errors": [
            1,
            3
        ]
    };
    desc("<p>In case of an error, the unrecognized tokens are handled as well as possible and returned in the stream " +
            "object's <code>errors</code> field.</p>", function () {
        var parser = new Playspecs.Parser.Parser({});
        var tokens = parser.tokenize("start bad , -> end");
        ex(tokens, expectedTokens);
    });
</script>
<p>The reference implementation tokenizes the entire string at once for clarity and simplicity. If the string to be
    parsed is large and contains something besides a Playspec at the beginning, or the Playspec is followed by a
    substantial amount of text, this could be inefficient. If this is important to your use case, you should
    redefine the <code>TokenStream</code> type to contain the current token and the unparsed remainder of
    the string, and reimplement <code>Parser.tokenize</code>, <code>Parser.advance</code>,
    <code>Parser.currentToken</code>, and <code>Parser.remainder</code> to tokenize as
    needed.</p>

<p>From the standpoint of Playspecs, the external API calls into the Parser to produce a parse tree of a Playspec from a
    string and a game-specific Context. The Context includes, among other things, data structures which teach the Parser
    how to parse game-specific syntax for atomic formulae (and, later, to give semantics to such syntax). Specifically,
    the Context has a so-called Token List represented as a JavaScript object. The schema of individual Token
    Definitions of that list is roughly:</p>
<pre>...
    tokens: [
        {
            type: "TOKEN_TYPE_A",
            match: Regex | String | [String],
            // The following fields are optional.
            [value: (MatchResult)=>any /* MatchResult is like the result of RegExp.exec() */,]
            [tightness: int,]
            [startParse: (Parser, Token)=>any /* Token is of type TOKEN_TYPE_A. Pratt's "nud". */ ,]
            [extendParse: (Parser, ParseTree, Token)=>any /* Token is of type TOKEN_TYPE_A. Pratt's "led". */ ]
        },
        ...
    ]
...</pre>
<p>Parser constructs its internal data structures from this schema. For each value in the tokens list, it builds its own
    Token Definition with the <code>type</code>, <code>match</code>, etc. During tokenization,
    each Token Definition is tried in turn (before Parser's internal Token List). If a token's
    <code>match</code> regular expression succeeds (or if its constant string or array of constant string is
    a prefix of the string), a Token object will be built with the corresponding type and the matched range of the
    stream. Its <code>value</code> will default to the matched string, but if the Token Definition defines a
    <code>value</code> field then the result of that function will be used instead.</p>

<p>In general, there is a trade-off between using complicated token match expressions and doing more parsing later on.
    In the PuzzleScript case, the language of patterns is matched easily by regular expressions and the token contains
    all the necessary information to check properties (in fact, we reuse most of PuzzleScript's own parsing machinery
    after we obtain e.g. a rule pattern). In Prom Week, the query syntax can be used in a variety of different
    contexts so it makes sense to separate the parsing into several steps which compose better. One important
    consideration is conflicts with the core Playspecs syntax: If a custom syntax wanted to recognize a <code>.</code>
    token, care must be taken to ensure it is not matched instead of the built-in <code>...</code> (e.g., with a regular
    expression like <code>/\.(?!\.)/</code>). Such conflicts will generally be evident at the time of use. Pratt parsing
    is token-directed, and since this reference implementation does not support extending existing tokens'
    <code>startParse</code> and <code>extendParse</code> functions, ambiguities are best avoided.</p>
<script>
    var expectedTokens = {
        "string": "start, not Chloe-dating-Doug ..., Doug-embarrassed-Chloe & end",
        "tokens": [
            {
                "type": "start",
                "value": "start",
                "tightness": 0,
                "range": {
                    "start": 0,
                    "end": 5
                }
            },
            {
                "type": ",",
                "value": ",",
                "tightness": 100,
                "range": {
                    "start": 5,
                    "end": 6
                }
            },
            {
                "type": "not",
                "value": "not",
                "tightness": 220,
                "range": {
                    "start": 7,
                    "end": 10
                }
            },
            {
                "type": "PERSON",
                "value": "Chloe",
                "tightness": 300,
                "range": {
                    "start": 11,
                    "end": 16
                }
            },
            {
                "type": "LINK",
                "value": "-",
                "tightness": 301,
                "range": {
                    "start": 16,
                    "end": 17
                }
            },
            {
                "type": "RELATIONSHIP",
                "value": "dating",
                "tightness": 300,
                "range": {
                    "start": 17,
                    "end": 23
                }
            },
            {
                "type": "LINK",
                "value": "-",
                "tightness": 301,
                "range": {
                    "start": 23,
                    "end": 24
                }
            },
            {
                "type": "PERSON",
                "value": "Doug",
                "tightness": 300,
                "range": {
                    "start": 24,
                    "end": 28
                }
            },
            {
                "type": "...",
                "value": {
                    "greedy": true,
                    "lowerBound": 0,
                    "upperBound": "$END"
                },
                "tightness": 110,
                "range": {
                    "start": 29,
                    "end": 32
                }
            },
            {
                "type": ",",
                "value": ",",
                "tightness": 100,
                "range": {
                    "start": 32,
                    "end": 33
                }
            },
            {
                "type": "PERSON",
                "value": "Doug",
                "tightness": 300,
                "range": {
                    "start": 34,
                    "end": 38
                }
            },
            {
                "type": "LINK",
                "value": "-",
                "tightness": 301,
                "range": {
                    "start": 38,
                    "end": 39
                }
            },
            {
                "type": "RELATIONSHIP",
                "value": "embarrassed",
                "tightness": 300,
                "range": {
                    "start": 39,
                    "end": 50
                }
            },
            {
                "type": "LINK",
                "value": "-",
                "tightness": 301,
                "range": {
                    "start": 50,
                    "end": 51
                }
            },
            {
                "type": "PERSON",
                "value": "Chloe",
                "tightness": 300,
                "range": {
                    "start": 51,
                    "end": 56
                }
            },
            {
                "type": "&",
                "value": "&",
                "tightness": 200,
                "range": {
                    "start": 57,
                    "end": 58
                }
            },
            {
                "type": "end",
                "value": "end",
                "tightness": 0,
                "range": {
                    "start": 59,
                    "end": 62
                }
            }
        ],
        "position": 0,
        "errors": []
    };
    desc("<p>For Prom Week, we want to describe network links and current relationships between characters. These " +
            "are mostly directional (though there are some bidirectional relationships), so we use a sort of labeled " +
            "edge syntax with an implied left-to-right orientation. Our token types are people, relationships, " +
            "networks, inequalities, and numbers. Let's tokenize a fragment of the Prom Week syntax:</p>", function () {
        var parser = new Playspecs.Parser.Parser({
            tokens: [
                {
                    type: "PERSON",
                    match: ["Chloe", "Simon", "Phoebe", "Doug"/*, ... */]
                },
                {
                    type: "RELATIONSHIP",
                    match: ["dating", "friends", "enemies", "embarrassed"/*, ... */]
                },
                {
                    type: "LINK",
                    match: "-",
                    // Custom tokens have their own precedence scale and always bind tighter than built-in ones.
                    tightness: 1
                }
                // Also: networks, inequalities, numbers
            ]
        });
        var tokens = parser.tokenize("start, not Chloe-dating-Doug ..., Doug-embarrassed-Chloe & end");
        ex(tokens, expectedTokens);
    });
</script>
<h2>Parsing</h2>

<p>Pratt parsers are modified recursive descent parsers that achieve great practical efficiency by being token-directed.
    While the external API is <code>parse(s:string):ParseResult</code>, each internal recursion goes through a
    designated function <code>parseExpression(tightness:number):ParseTree</code>, which starts by taking
    the first token off of <code>s</code> and calling its <code>startParse</code> function, yielding an initial
    <code>ParseTree</code> (this call might itself recurse into <code>parseExpression</code>). Having the initial tree
    in hand, it now tries to extend this tree as far as operator precedence allows (according to the
    <code>tightness</code> parameter). <code>parseExpression</code> repeatedly looks at the now-current token (since
    <code>startParse</code> might have consumed tokens on its own, this may not be the immediately subsequent token to
    the first one) and verifies that its <code>tightness</code> is greater than that of the call to
    <code>parseExpression</code>: in other words, whether this operator binds tighter than the operator just above the
    call to <code>parseExpression</code>. If so, that operator's <code>extendParse</code> function is called (again, it
    might recurse into <code>parseExpression</code>, possibly with a different <code>tightness</code>) and the current
    parse tree is replaced by its result. If not, the current parse tree is returned.</p>

<p><code>ParseTree</code> nodes are constructed via the <code>Parser.node</code> method, which implementations of
    <code>startParse</code> and <code>extendParse</code> should call. Character ranges are associated with each node
    based on the consumed tokens. Errors are a special kind of parse node constructed by <code>Parser.error</code>, and
    they are placed into the tree where the error occurs. They are also recorded in the <code>errors</code> field of
    <code>Parser</code> and returned along with the final parse tree and the remainder of the string. If a token is in
    a parse-starting or parse-extending position but does not define <code>startParse</code> or <code>extendParse</code>
    (respectively), the default behavior is to signal a syntax error.</p>

<script>
    var expectedParseResult = {
        "tree": {
            "type": ",",
            "value": ",",
            "children": [
                {
                    "type": "start",
                    "value": "start",
                    "children": [],
                    "range": {
                        "start": 0,
                        "end": 5
                    }
                },
                {
                    "type": ",",
                    "value": ",",
                    "children": [
                        {
                            "type": "...",
                            "value": {
                                "greedy": true,
                                "lowerBound": 0,
                                "upperBound": "$END"
                            },
                            "children": [
                                {
                                    "type": "not",
                                    "value": "not",
                                    "children": [
                                        {
                                            "type": "LINK_RELATIONSHIP",
                                            "children": [
                                                {
                                                    "type": "PERSON",
                                                    "value": "Chloe",
                                                    "children": [],
                                                    "range": {
                                                        "start": 11,
                                                        "end": 16
                                                    }
                                                },
                                                {
                                                    "type": "RELATIONSHIP",
                                                    "value": "dating",
                                                    "children": [],
                                                    "range": {
                                                        "start": 17,
                                                        "end": 23
                                                    }
                                                },
                                                {
                                                    "type": "PERSON",
                                                    "value": "Doug",
                                                    "children": [],
                                                    "range": {
                                                        "start": 24,
                                                        "end": 29
                                                    }
                                                }
                                            ],
                                            "range": {
                                                "start": 11,
                                                "end": 29
                                            }
                                        }
                                    ],
                                    "range": {
                                        "start": 7,
                                        "end": 29
                                    }
                                }
                            ],
                            "range": {
                                "start": 7,
                                "end": 32
                            }
                        },
                        {
                            "type": "&",
                            "value": "&",
                            "children": [
                                {
                                    "type": "LINK_RELATIONSHIP",
                                    "children": [
                                        {
                                            "type": "PERSON",
                                            "value": "Doug",
                                            "children": [],
                                            "range": {
                                                "start": 34,
                                                "end": 38
                                            }
                                        },
                                        {
                                            "type": "RELATIONSHIP",
                                            "value": "embarrassed",
                                            "children": [],
                                            "range": {
                                                "start": 39,
                                                "end": 50
                                            }
                                        },
                                        {
                                            "type": "PERSON",
                                            "value": "Chloe",
                                            "children": [],
                                            "range": {
                                                "start": 51,
                                                "end": 57
                                            }
                                        }
                                    ],
                                    "range": {
                                        "start": 34,
                                        "end": 57
                                    }
                                },
                                {
                                    "type": "end",
                                    "value": "end",
                                    "children": [],
                                    "range": {
                                        "start": 59,
                                        "end": 62
                                    }
                                }
                            ],
                            "range": {
                                "start": 34,
                                "end": 62
                            }
                        }
                    ],
                    "range": {
                        "start": 7,
                        "end": 62
                    }
                }
            ],
            "range": {
                "start": 0,
                "end": 62
            }
        },
        "errors": [],
        "remainder": ""
    };
    desc("<p>Returning to Prom Week, let's implement parsers for the three token types we saw before. " +
            "<code>PERSON</code> and <code>RELATIONSHIP</code> are inert values, so we can implement " +
            "<code>startParse</code> using <code>Parser.parseValue</code> as a convenient shorthand. Another useful" +
            "shortcut to remember is <code>Parser.parseInfixR</code> for right-associative infix operators, though" +
            "it won't come up in this example. The <code>LINK</code> token type, however, is a kind of ternary " +
            "operator, so we must parse it by hand with several recursive calls to <code>Parser/parseExpression</code>." +
            "Note that <code>LINK</code> cannot appear at the beginning of a parse, so it only provides " +
            "<code>extendParse</code>.</p>", function () {
        var parser = new Playspecs.Parser.Parser({
            tokens: [
                {
                    type: "PERSON",
                    match: ["Chloe", "Simon", "Phoebe", "Doug"/*, ... */],
                    startParse: Playspecs.Parser.parseValue
                },
                {
                    type: "RELATIONSHIP",
                    match: ["dating", "friends", "enemies", "embarrassed"/*, ... */],
                    startParse: Playspecs.Parser.parseValue
                },
                {
                    type: "LINK",
                    match: "-",
                    // Custom tokens have their own precedence scale and always bind tighter than built-in ones.
                    tightness: 1,
                    extendParse: function (parser, parseTree, token) {
                        var left = parseTree;
                        if (left.type != "PERSON") {
                            return parser.error("Left hand side of LINK must be PERSON", token, parseTree);
                        }
                        // Links are not associative, so we must parse at a higher tightness.
                        // In other words, this call to parseExpression will never try to extend the given parse
                        // using a LINK or any lower-precedence term.
                        var relationship = parser.parseExpression(token.tightness);
                        // A real implementation would handle inequalities over network values too.
                        if (relationship.type != "RELATIONSHIP") {
                            return parser.error("Middle term of LINK must be RELATIONSHIP", token, relationship);
                        }
                        // We need to examine the next token without running parseExpression again to know if the
                        // LINK syntax is being used correctly.
                        var current = parser.currentToken();
                        if (current.type != "LINK") {
                            return parser.error(
                                    "A second LINK token must appear after the middle term of a LINK",
                                    current
                            );
                        }
                        parser.advance();
                        var right = parser.parseExpression(token.tightness + 1);
                        if (right.type != "PERSON") {
                            return parser.error("Right hand side of LINK must be PERSON", token, right);
                        }
                        // We'll keep all three parse trees around to maintain location information, etc.
                        return parser.node("LINK_RELATIONSHIP", undefined, [left, relationship, right]);
                    }
                }
                // Also: networks, inequalities, numbers
            ]
        });
        var parseResult = parser.parse("start, not Chloe-dating-Doug ..., Doug-embarrassed-Chloe & end");
        ex(parseResult, expectedParseResult);
    });
    var promWeekContext = {
        tokens: [
            {
                type: "PERSON",
                match: ["Chloe", "Simon", "Phoebe", "Doug"/*, ... */],
                startParse: Playspecs.Parser.parseValue
            },
            {
                type: "RELATIONSHIP",
                match: ["dating", "friends", "enemies", "embarrassed"/*, ... */],
                startParse: Playspecs.Parser.parseValue
            },
            {
                type: "LINK",
                match: "-",
                // Custom tokens have their own precedence scale and always bind tighter than built-in ones.
                tightness: 1,
                extendParse: function (parser, parseTree, token) {
                    var left = parseTree;
                    if (left.type != "PERSON") {
                        return parser.error("Left hand side of LINK must be PERSON", token, parseTree);
                    }
                    // Links are not associative, so we must parse at a higher tightness.
                    // In other words, this call to parseExpression will never try to extend the given parse
                    // using a LINK or any lower-precedence term.
                    var relationship = parser.parseExpression(token.tightness);
                    // A real implementation would handle inequalities over network values too.
                    if (relationship.type != "RELATIONSHIP") {
                        return parser.error("Middle term of LINK must be RELATIONSHIP", token, relationship);
                    }
                    // We need to examine the next token without running parseExpression again to know if the
                    // LINK syntax is being used correctly.
                    var current = parser.currentToken();
                    if (current.type != "LINK") {
                        return parser.error(
                                "A second LINK token must appear after the middle term of a LINK",
                                current
                        );
                    }
                    parser.advance();
                    var right = parser.parseExpression(token.tightness + 1);
                    if (right.type != "PERSON") {
                        return parser.error("Right hand side of LINK must be PERSON", token, right);
                    }
                    // We'll keep all three parse trees around to maintain location information, etc.
                    return parser.node("LINK_RELATIONSHIP", undefined, [left, relationship, right]);
                }
            }
            // Also: networks, inequalities, numbers
        ]
    };
    expectedParseResult = {
        "tree": {
            "type": "ERROR",
            "value": {
                "message": "Left hand side of LINK must be PERSON",
                "token": {
                    "type": "LINK",
                    "value": "-",
                    "tightness": 301,
                    "range": {
                        "start": 17,
                        "end": 18
                    }
                },
                "tree": {
                    "type": "LINK_RELATIONSHIP",
                    "children": [
                        {
                            "type": "PERSON",
                            "value": "Chloe",
                            "children": [],
                            "range": {
                                "start": 0,
                                "end": 5
                            }
                        },
                        {
                            "type": "RELATIONSHIP",
                            "value": "dating",
                            "children": [],
                            "range": {
                                "start": 6,
                                "end": 12
                            }
                        },
                        {
                            "type": "PERSON",
                            "value": "Doug",
                            "children": [],
                            "range": {
                                "start": 13,
                                "end": 17
                            }
                        }
                    ],
                    "range": {
                        "start": 0,
                        "end": 17
                    }
                }
            },
            "children": [],
            "range": {
                "start": 0,
                "end": 18
            }
        },
        "errors": [
            {
                "type": "ERROR",
                "value": {
                    "message": "Left hand side of LINK must be PERSON",
                    "token": {
                        "type": "LINK",
                        "value": "-",
                        "tightness": 301,
                        "range": {
                            "start": 17,
                            "end": 18
                        }
                    },
                    "tree": {
                        "type": "LINK_RELATIONSHIP",
                        "children": [
                            {
                                "type": "PERSON",
                                "value": "Chloe",
                                "children": [],
                                "range": {
                                    "start": 0,
                                    "end": 5
                                }
                            },
                            {
                                "type": "RELATIONSHIP",
                                "value": "dating",
                                "children": [],
                                "range": {
                                    "start": 6,
                                    "end": 12
                                }
                            },
                            {
                                "type": "PERSON",
                                "value": "Doug",
                                "children": [],
                                "range": {
                                    "start": 13,
                                    "end": 17
                                }
                            }
                        ],
                        "range": {
                            "start": 0,
                            "end": 17
                        }
                    }
                },
                "children": [],
                "range": {
                    "start": 0,
                    "end": 18
                }
            }
        ],
        "remainder": "embarrassed-Simon"
    };
    desc("<p>Parse errors are placed directly into the tree and also appear in a separate list. In this case, the " +
            "<code>LINK_RELATIONSHIP</code> tree can't be extended by another <code>LINK</code>. The parse " +
            "terminates right away, leaving the remainder of the string alone.</p>", function () {
        var parser = new Playspecs.Parser.Parser(promWeekContext);
        var parseResult = parser.parse("Chloe-dating-Doug-embarrassed-Simon");
        ex(parseResult, expectedParseResult);
    });
</script>
<p>One common source of parse errors is that the logical connectives <code>and</code>, <code>or</code>, and
    <code>not</code> may only be combined with other propositional terms: i.e., other logical connectives, custom
    game-specific terms, <code>true</code>, <code>false</code>, <code>start</code>, <code>end</code>, and parenthesized
    groups which only contain a propositional term. Such errors are detected at parse time, although some others
    cannot be detected until <a href="compiler.html">compile time</a>.</p>

</body>
</html>