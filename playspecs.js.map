{"version":3,"sources":["webpack:///webpack/bootstrap 6acc79400936f86af468","webpack:///./playspecs.js","webpack:///./parser.js","webpack:///./compiler.js","webpack:///./playspec.js"],"names":[],"mappings":"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","file":"playspecs.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6acc79400936f86af468\n **/","/* @flow */\n\n//const Parser = require(\"parser.js\").Parser;\n//\n//var p = new Parser();\n//\n//console.log(p);\n//\n//export Parser;\n\nimport * as ParserExports from \"./parser\";\nimport {default as CompilerExports} from \"./compiler\";\nimport {default as PlayspecExports} from \"./playspec\";\n\nexport const Parser = ParserExports;\nexport const Compiler = CompilerExports;\nexport const Playspec = PlayspecExports;\n\n\n/** WEBPACK FOOTER **\n ** ./playspecs.js\n **/","/* @flow */\n\nexport const tokenTypes:{ [key: string]: string } = {\n    WHITESPACE: \" \",\n    CONCATENATION: \",\",\n    // Bounding integers are tokenized as part of the dots to minimize potential conflicts with user-provided syntax.\n    DOTS_GREEDY: \"...\",\n    DOTS_RELUCTANT: \"..\",\n    DOTS_OMEGA: \"***\",\n    LEFT_PAREN: \"(\",\n    RIGHT_PAREN: \")\",\n    ALTERNATION: \";\",\n    INTERSECTION: \"^\",\n    AND: \"&\",\n    OR: \"|\",\n    NOT: \"not\",\n    START: \"start\",\n    END: \"end\",\n    TRUE: \"true\",\n    FALSE: \"false\",\n    ERROR: \"error\"\n};\n\nexport const parseTypes:{ [key: string]: string } = {\n    OMEGA: tokenTypes.DOTS_OMEGA,\n    REPETITION: tokenTypes.DOTS_GREEDY,\n    CONCATENATION: tokenTypes.CONCATENATION,\n    GROUP: tokenTypes.LEFT_PAREN,\n    ALTERNATION: tokenTypes.ALTERNATION,\n    INTERSECTION: tokenTypes.INTERSECTION,\n    AND: tokenTypes.AND,\n    OR: tokenTypes.OR,\n    NOT: tokenTypes.NOT,\n    START: tokenTypes.START,\n    END: tokenTypes.END,\n    TRUE: tokenTypes.TRUE,\n    FALSE: tokenTypes.FALSE,\n    ERROR: tokenTypes.ERROR\n};\n\ntype\nMatchResult = Array < string >;\n\ntype\nTokenDefinition = Array < {\n        type: string,\n        match: string | Array < string > | RegExp,\n        value? : ((mr:MatchResult) => any),\n        tightness? : number,\n        startParse? : ((p:Parser, t:Token) => ParseTree),\n        extendParse? : ((p:Parser, pt:ParseTree, t:Token) => ParseTree)\n    } >;\n\ntype\nToken = {\n    type: string,\n    value: any,\n    // A bit redundant, but makes defining generic startParse/extendParse functions easier.\n    tightness: number,\n    range: {start: number, end: number}\n};\n\ntype\nParseTree = {\n    type: string,\n    value: any,\n    children: Array < ParseTree >,\n    range: {start: number, end: number}\n};\n\ntype\nTokenStream = {\n    string: string,\n    tokens: Array < Token >,\n    position: number,\n    errors: Array < number >\n};\n\nexport const constantValue = function (c:any) {\n    return function (_mr:MatchResult) {\n        return c;\n    }\n};\n\nexport const parseValue = function (parser:Parser, token:Token) {\n    return parser.node(token.type, token.value);\n};\n\nexport const parseInfixR = function (parser:Parser, left:ParseTree, token:Token) {\n    let children = [left];\n    children.push(parser.parseExpression(token.tightness - 1));\n    return parser.node(token.type, token.value, children);\n};\n\nexport const parseInfixRPropositional = function (parser:Parser, left:ParseTree, token:Token) {\n    if (!isPropositional(left)) {\n        return parser.error(\"Left hand side of token must be propositional\", token, left);\n    }\n    let children = [left];\n    const right = parser.parseExpression(token.tightness - 1);\n    if (!isPropositional(right)) {\n        return parser.error(\"Right hand side of token must be propositional\", token, right);\n    }\n    children.push(right);\n    return parser.node(token.type, token.value, children);\n};\n\nexport const BOUND_INFINITE = \"$END\";\n\nexport const standardTokens:Array<TokenSchema> = [\n    {\n        type: tokenTypes.WHITESPACE,\n        match: /^\\s+/\n    },\n    {\n        type: tokenTypes.CONCATENATION,\n        match: [tokenTypes.CONCATENATION],\n        tightness: 100,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.DOTS_GREEDY,\n        match: /^([0-9]*)\\s*\\.\\.\\.\\s*([0-9]*)/,\n        value: function (matchResult:MatchResult):any {\n            return {\n                greedy: true,\n                lowerBound: matchResult[1] ? parseInt(matchResult[1]) : 0,\n                upperBound: matchResult[2] ? parseInt(matchResult[2]) : BOUND_INFINITE\n            };\n        },\n        tightness: 110,\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.start;\n            return parser.node(parseTypes.REPETITION, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.REPETITION, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.DOTS_RELUCTANT,\n        match: /^([0-9]*)\\s*\\.\\.\\s*([0-9]*)/,\n        tightness: 110,\n        value: function (matchResult:MatchResult) {\n            return {\n                greedy: false,\n                lowerBound: matchResult[1] ? parseInt(matchResult[1]) : 0,\n                upperBound: matchResult[2] ? parseInt(matchResult[2]) : BOUND_INFINITE\n            };\n        },\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.start;\n            return parser.node(parseTypes.REPETITION, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.REPETITION, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.DOTS_OMEGA,\n        match: [tokenTypes.DOTS_OMEGA],\n        tightness: 110,\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.end;\n            return parser.node(parseTypes.OMEGA, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.OMEGA, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.LEFT_PAREN,\n        match: [tokenTypes.LEFT_PAREN],\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            //parse an expression at RBP 0, then eat a )\n            const expr = parser.parseExpression(0);\n            if (parser.currentToken().type != tokenTypes.RIGHT_PAREN) {\n                return parser.error(\"Missing right parenthesis\", token, expr);\n            }\n            parser.advance();\n            return parser.node(parseTypes.GROUP, token.value, [expr]);\n        }\n    },\n    {\n        type: tokenTypes.RIGHT_PAREN,\n        match: [tokenTypes.RIGHT_PAREN]\n    },\n    {\n        type: tokenTypes.ALTERNATION,\n        match: [tokenTypes.ALTERNATION],\n        tightness: 60,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.INTERSECTION,\n        match: [tokenTypes.INTERSECTION],\n        tightness: 50,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.AND,\n        match: [tokenTypes.AND],\n        tightness: 200,\n        extendParse: parseInfixRPropositional\n    },\n    {\n        type: tokenTypes.OR,\n        match: [tokenTypes.OR],\n        tightness: 210,\n        extendParse: parseInfixRPropositional\n    },\n    {\n        type: tokenTypes.NOT,\n        match: [tokenTypes.NOT],\n        tightness: 220,\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const phi = parser.parseExpression(token.tightness);\n            if (!isPropositional(phi)) {\n                return parser.error(\"NOT may only negate propositional state formulae\", token, phi);\n            }\n            return parser.node(token.type, token.value, [phi]);\n        }\n    },\n    {\n        type: tokenTypes.START,\n        match: [tokenTypes.START],\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.END,\n        match: [tokenTypes.END],\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.TRUE,\n        match: [tokenTypes.TRUE],\n        value: constantValue(true),\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.FALSE,\n        match: [tokenTypes.FALSE],\n        value: constantValue(false),\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.ERROR,\n        match: /^\\S+/,\n        startParse: parseValue\n    }\n];\n\nconst customTightnessOffset = 300;\n\nconst ERROR = \"ERROR\";\n\nfunction isString(s:any):bool {\n    return typeof s === 'string' || s instanceof String;\n}\n\nexport function isCustom(p:ParseTree):bool {\n    for (var k in parseTypes) {\n        if (parseTypes[k] == p.type) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function isPropositional(p:ParseTree):bool {\n    return isCustom(p) ||\n        p.type == parseTypes.AND ||\n        p.type == parseTypes.OR ||\n        p.type == parseTypes.NOT ||\n        p.type == parseTypes.TRUE ||\n        p.type == parseTypes.FALSE ||\n        p.type == parseTypes.START ||\n        p.type == parseTypes.END ||\n        (p.type == parseTypes.GROUP &&\n        p.children.every(function (c) {\n            return isPropositional(c);\n        }));\n}\n\nexport class Parser {\n    constructor(context) {\n        this.tokenDefinitions = [];\n        this.tokensByType = {};\n        this.parseErrors = [];\n        const customTokens = context.tokens || [];\n        const tokens = customTokens.concat(standardTokens);\n        for (let ti = 0; ti < tokens.length; ti++) {\n            const input = tokens[ti];\n            const tightness = input.tightness || 0;\n            const defn = {\n                type: input.type,\n                match: isString(input.match) ? [input.match] : input.match,\n                value: input.value || function (mr) {\n                    return mr[0];\n                },\n                tightness: ti < customTokens.length ? tightness + customTightnessOffset : tightness,\n                startParse: input.startParse || function (parser, token) {\n                    return parser.error(\"Can't start a parse tree with this token\", token);\n                },\n                extendParse: input.extendParse || function (parser, token, parseTree) {\n                    return parser.error(\"Can't extend a parse tree with this token\", token, parseTree);\n                }\n            };\n            this.tokenDefinitions.push(defn);\n            this.tokensByType[defn.type] = defn;\n        }\n        this.resetStream();\n    }\n\n    node(type:string, value:any = undefined, children:Array<ParseTree> = []):ParseTree {\n        return {type, value, children, range: {start: -1, end: -1}};\n    }\n\n    error(msg:string, token:Token, tree:ParseTree = undefined):ParseTree {\n        const err = this.node(ERROR, {message: msg, token, tree});\n        this.parseErrors.push(err);\n        return err;\n    }\n\n    tokenize(str:string):TokenStream {\n        let result:Array<Token> = [];\n        let errors:Array<number> = [];\n        let substring:string = str;\n        let index:number = 0;\n        while (substring.length) {\n            for (let ti = 0; ti < this.tokenDefinitions.length; ti++) {\n                const tokenDefinition = this.tokenDefinitions[ti];\n                const match = tokenDefinition.match;\n                let matchResult = null;\n                if (match instanceof RegExp) {\n                    matchResult = match.exec(substring);\n                } else if (Array.isArray(match)) {\n                    for (let mi = 0; mi < match.length; mi++) {\n                        const candidate = match[mi];\n                        if (substring.substr(0, candidate.length) == candidate) {\n                            matchResult = [candidate];\n                            matchResult.index = 0;\n                        }\n                    }\n                }\n                if (matchResult && matchResult.index == 0) {\n                    const matchLength = matchResult[0].length;\n                    substring = substring.substr(matchResult[0].length);\n                    const oldIndex = index;\n                    index += matchLength;\n                    if (tokenDefinition.type !== tokenTypes.WHITESPACE) {\n                        if (tokenDefinition.type === tokenTypes.ERROR) {\n                            errors.push(result.length);\n                        }\n                        result.push({\n                            type: tokenDefinition.type,\n                            value: tokenDefinition.value(matchResult),\n                            tightness: tokenDefinition.tightness,\n                            range: {start: oldIndex, end: index}\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        return {string: str, tokens: result, position: 0, errors: errors};\n    }\n\n    resetStream():void {\n        this.stream = {string: \"\", tokens: [], position: 0, errors: []};\n    }\n\n    charPosition():number {\n        return this.currentToken() ? this.currentToken().range.start : this.stream.string.length;\n    }\n\n    remainder():string {\n        const end = this.charPosition();\n        return this.stream.string.substr(end);\n    }\n\n    currentToken():Token {\n        return this.stream.tokens[this.stream.position];\n    }\n\n    advance():void {\n        this.stream.position++;\n    }\n\n    parse(str:string):{tree:ParseTree, errors:Array<ParseTree>, remainder:string} {\n        this.stream = this.tokenize(str);\n        this.parseErrors = [];\n        const tree = this.parseExpression(0);\n        var result = {tree, errors: this.parseErrors, remainder: this.remainder()};\n        this.parseErrors = [];\n        this.resetStream();\n        return result;\n    }\n\n    parseExpression(tightness:number):ParseTree {\n        let token = this.currentToken();\n        let tokenDef = this.tokensByType[token.type];\n        const start = token.range.start;\n        this.advance();\n        let tree = tokenDef.startParse(this, token);\n        tree.range.start = start;\n        tree.range.end = this.charPosition();\n        if (tree.type == ERROR) {\n            return tree;\n        }\n        token = this.currentToken();\n        while (token && tightness < token.tightness) {\n            tokenDef = this.tokensByType[token.type];\n            this.advance();\n            let newTree = tokenDef.extendParse(this, tree, token);\n            newTree.range.start = tree.range.start;\n            newTree.range.end = this.charPosition();\n            if (newTree.type == ERROR) {\n                return newTree;\n            }\n            tree = newTree;\n            token = this.currentToken();\n        }\n        return tree;\n    }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./parser.js\n **/","/* @flow */\n\nimport {parseTypes, isPropositional, BOUND_INFINITE} from \"./parser\";\n\ntype\nInstruction =\n    {type: \"check\", formula: ParseTree, index? : number, source? : \"root\" | ParseTree} |\n    {type: \"jump\", target: number, index? : number, source? : \"root\" | ParseTree} |\n    {type: \"split\", left: number, right: number, index? : number, source? : \"root\" | ParseTree} |\n    {type: \"match\", index? : number, source? : \"root\" | ParseTree} |\n    {type: \"start\", group: string | number, index? : number, source? : \"root\" | ParseTree} |\n    {type: \"end\", group: string | number, index? : number, source? : \"root\" | ParseTree};\ntype\nProgram = Array < Instruction >;\n\nexport default class Compiler {\n    constructor(_ctx) {\n\n    }\n\n    compileTree(tree:ParseTree, idx:number):Program {\n        //console.log(`compile ${tree.type} at index ${idx}`);\n        if (tree.type == parseTypes.GROUP) {\n            // TODO: submatch saving\n            return this.compileTree(tree.children[0], idx);\n        }\n        if (isPropositional(tree)) {\n            //console.log(\"tree \" + JSON.stringify(tree) + \":\" + tree.type + \" is propositional\");\n            return [{type: \"check\", formula: tree, index: idx, source: tree}];\n        }\n        if (tree.type == parseTypes.CONCATENATION) {\n            const aIdx = idx;\n            const a = this.compileTree(tree.children[0], aIdx);\n            const bIdx = idx + a.length;\n            const b = this.compileTree(tree.children[1], bIdx);\n            return a.concat(b);\n        }\n        if (tree.type == parseTypes.ALTERNATION) {\n            // branch; but need to compile left first.\n            // left:\n            const aIdx = idx + 1;\n            const left = this.compileTree(tree.children[0], aIdx);\n            const bIdx = aIdx + left.length + 1; // Leave room for jump after left\n            // now we can define branch, which goes before left:\n            const branch = [{type: \"split\", left: aIdx, right: bIdx, index: idx, source: tree}];\n            // right:\n            const right = this.compileTree(tree.children[1], bIdx);\n            const cIdx = bIdx + right.length;\n            const jump = [{type: \"jump\", target: cIdx, index: aIdx + left.length, source: tree}];\n            return branch.concat(left).concat(jump).concat(right);\n        }\n        if (tree.type == parseTypes.INTERSECTION) {\n            // TODO: intersection\n        }\n        if (tree.type == parseTypes.REPETITION) {\n            const greedy = tree.value.greedy;\n            const min = tree.value.lowerBound;\n            const phi = tree.children[0];\n            // min repetitions of phi\n            let preface = [];\n            for (let i = 0; i < min; i++) {\n                const phiPgm = this.compileTree(phi, idx);\n                idx += phiPgm.length;\n                preface.push(...phiPgm);\n            }\n            if (tree.value.upperBound != BOUND_INFINITE) {\n                // M-N repetitions of (phi?)\n                const max = tree.value.upperBound;\n                let optionals = [];\n                let targets = [];\n                for (let i = min; i < max; i++) {\n                    // make room for split li,lZ\n                    idx = idx + 1;\n                    // store jump target li in targets\n                    targets.push(idx);\n                    const phiPgm = this.compileTree(phi, idx);\n                    // make room for phiPgm\n                    idx += phiPgm.length;\n                    optionals.push(phiPgm);\n                }\n                //idx is now just past the end of all the \"optionals\".\n                let repetition = [];\n                for (let i = 0; i < optionals.length; i++) {\n                    repetition.push({\n                        type: \"split\",\n                        left: (greedy ? targets[i] : idx),\n                        right: (greedy ? idx : targets[i]),\n                        index: targets[i] - 1,\n                        source: tree\n                    });\n                    repetition.push(...(optionals[i]));\n                }\n                return preface.concat(repetition);\n            } else {\n                // A: split B, C; but must compile B first to get label for C\n                const aIdx = idx;\n                // make room for the split\n                const bIdx = aIdx + 1;\n                // then put in B\n                const b = this.compileTree(phi, bIdx);\n                const jump = [{type: \"jump\", target: aIdx, index: bIdx + b.length, source: tree}];\n                // then label C\n                const cIdx = bIdx + b.length + 1;\n                const branch = [{\n                    type: \"split\",\n                    left: (greedy ? bIdx : cIdx),\n                    right: (greedy ? cIdx : bIdx),\n                    index: idx,\n                    source: tree\n                }];\n                return preface.concat(branch).concat(b).concat(jump);\n            }\n        }\n        throw new Error(\"Can't compile \" + JSON.stringify(tree));\n        return [];\n    }\n\n    compile(tree:ParseTree, debug:bool = false):Program {\n        if (!tree.type && tree.tree && tree.errors && tree.remainder) {\n            throw new Error(\n                \"Received a ParseResult, but expected a ParseTree.\" +\n                \"Call compile() with the .tree element of \" + tree\n            );\n        }\n        // We preface every program with \"true ..\" so that all Playspecs are effectively start-anchored.\n        // This is as per https://swtch.com/~rsc/regexp/regexp2.html\n        const preface = [\n            {type: \"split\", left: 3, right: 1, index: 0, source: \"root\"},\n            {\n                type: \"check\",\n                formula: {\n                    type: parseTypes.TRUE,\n                    value: true,\n                    children: [],\n                    range: {start: 0, end: 0}\n                },\n                index: 1,\n                source: \"root\"\n            },\n            {type: \"jump\", target: 0, index: 2, source: \"root\"},\n            {type: \"start\", group: \"$root\", index: 3, source: \"root\"}\n        ];\n        const body = this.compileTree(tree, preface.length);\n        const result = preface.concat(body).concat([\n            {\n                type: \"end\",\n                group: \"$root\",\n                index: preface.length + body.length,\n                source: \"root\"\n            },\n            {\n                type: \"match\",\n                index: preface.length + body.length + 1,\n                source: \"root\"\n            }\n        ]);\n        if (!this.validate(result)) {\n            throw new Error(\n                \"Error compiling tree \" + JSON.stringify(tree) + \" into result \" + JSON.stringify(result)\n            );\n        }\n        if (!debug) {\n            for (let i = 0; i < result.length; i++) {\n                delete result[i].source;\n                delete result[i].index;\n            }\n        }\n        return result;\n    }\n\n    validate(pgm:Program):bool {\n        // todo: validate programs against some basic sanity checks.\n        //ensure each instruction's index is its index in pgm\n        //ensure no split or jump goes beyond end of program\n        //...\n        return true;\n    }\n\n    stringifyCustom(formula:ParseTree):string {\n        const value = formula.value === undefined ? \"\" : formula.value.toString();\n        const children = formula.children && formula.children.length ?\n            (formula.children.map((c) => this.stringifyFormula(c))).join(\",\") :\n            \"\";\n        return `${formula.type}(${value},${children})`;\n    }\n\n    stringifyFormula(formula:ParseTree):string {\n        switch (formula.type) {\n            case parseTypes.TRUE:\n                return \"true\";\n            case parseTypes.FALSE:\n                return \"false\";\n            case parseTypes.START:\n                return \"start\";\n            case parseTypes.END:\n                return \"end\";\n            case parseTypes.AND:\n                return `${this.stringifyFormula(formula.children[0])} & ${this.stringifyFormula(formula.children[1])}`;\n            case parseTypes.OR:\n                return `${this.stringifyFormula(formula.children[0])} | ${this.stringifyFormula(formula.children[1])}`;\n            case parseTypes.NOT:\n                return `not ${this.stringifyFormula(formula.children[0])}`;\n            case parseTypes.GROUP:\n                return `(${this.stringifyFormula(formula.children[0])})`;\n            default:\n                return this.stringifyCustom(formula);\n        }\n    }\n\n    stringify(code:Program):string {\n        let result = [];\n        for (let i = 0; i < code.length; i++) {\n            const instr = code[i];\n            let instrStr = `${i}:${instr.type}`;\n            switch (instr.type) {\n                case \"split\":\n                    instrStr += ` ${instr.left} ${instr.right}`;\n                    break;\n                case \"jump\":\n                    instrStr += ` ${instr.target}`;\n                    break;\n                case \"check\":\n                    instrStr += \" \" + this.stringifyFormula(instr.formula);\n                    break;\n                case \"start\":\n                case \"end\":\n                    instrStr += ` ${instr.group}`;\n                    break;\n                case \"match\":\n                    break;\n                default:\n                    throw new Error(\"Unrecognized instruction \" + instr);\n            }\n            if (instr.source) {\n                if (instr.source == \"root\") {\n                    instrStr += \"  \\t\\t(root)\";\n                } else {\n                    if (instr.type == \"check\") {\n                        instrStr += `\\t(ch. ${instr.source.range.start}-${instr.source.range.end})`;\n                    } else {\n                        instrStr += `\\t\\t(${instr.source.type} ${JSON.stringify(instr.source.value)})`;\n                    }\n                }\n            }\n            result.push(instrStr);\n        }\n        return result.join(\"\\n\");\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./compiler.js\n **/","/* @flow */\n\nimport {parseTypes, Parser} from \"./parser.js\";\nimport Compiler from \"./compiler.js\";\n\nexport default class Playspec {\n    constructor(spec:string, context, debug:boolean = false) {\n        this.checkAPI = context.checks;\n        this.traceAPI = context.trace;\n        this.spec = spec;\n        const parser = new Parser(context);\n        const compiler = new Compiler(context);\n        this.parseResult = parser.parse(spec);\n        this.program = compiler.compile(this.parseResult.tree, debug);\n    }\n\n    check(trace:Trace<State>, state:State, idx:number, formula:ParseTree):Boolean {\n        switch (formula.type) {\n            case parseTypes.TRUE:\n                return true;\n            case parseTypes.FALSE:\n                return false;\n            case parseTypes.START:\n                return idx == 0;\n            case parseTypes.END:\n                return this.traceAPI.isAtEnd(trace);\n            case parseTypes.AND:\n                return this.check(trace, state, idx, formula.children[0]) &&\n                    this.check(trace, state, idx, formula.children[1]);\n            case parseTypes.OR:\n                return this.check(trace, state, idx, formula.children[0]) ||\n                    this.check(trace, state, idx, formula.children[1]);\n            case parseTypes.NOT:\n                return !this.check(trace, state, idx, formula.children[0]);\n            case parseTypes.GROUP:\n                return this.check(trace, state, idx, formula.children[0]);\n            default:\n                if (this.checkAPI[formula.type]) {\n                    return this.checkAPI[formula.type](trace, state, idx, formula);\n                } else {\n                    throw new Error(\"Unrecognized propositional formula\");\n                }\n        }\n    }\n\n    match(trace:Trace<State>, preserveStates:boolean = false):PlayspecResult {\n        return (new PlayspecResult({\n            spec: this,\n            preserveStates\n        }, {trace: trace}, undefined)).next();\n    }\n}\n\nclass Thread {\n    constructor(id:number, pc:number, priority:number, matches:Array<Match>) {\n        this.id = id;\n        this.pc = pc;\n        this.priority = priority;\n        //match sharing: instead set this.matches to matches and set sharedMatches to true\n        this.matches = matches.map(function (m) {\n            let m2 = cloneMatch(m);\n            m2.priority = Math.max(priority, m.priority);\n            return m2;\n        });\n    }\n\n    equals(t2:Thread):boolean {\n        return this.pc == t2.pc;\n    }\n\n    hash():number {\n        return this.pc;\n    }\n\n    mergeThread(other:Thread) {\n        // Match sharing: if matches are shared, replace matches list with slice of matches list,\n        // and insert either clones of other's matches (if other is sharing matches) or other's matches directly\n        // Also update priority of new matches\n        for (let i = 0; i < other.matches.length; i++) {\n            let found = false;\n            for (let j = 0; j < this.matches.length; j++) {\n                if (matchEquivFn(this.matches[j], other.matches[i])) {\n                    found = true;\n                }\n            }\n            if (!found) {\n                let match = cloneMatch(other.matches[i]);\n                match.priority = Math.max(this.priority, this.matches[i].priority);\n                this.matches.push(match);\n            }\n        }\n        // Merge any other state\n    }\n\n    hasOpenMatch():boolean {\n        for (let i = 0; i < this.matches.length; i++) {\n            if (this.matches[i].instructions.length > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    pushMatchInstruction(instr:MatchInstruction) {\n        // Match sharing: if matches are shared, replace matches list with a new list containing clones of matches\n        // Also update priority of matches\n        // And set sharedMatches to false\n        for (let i = 0; i < this.matches.length; i++) {\n            this.matches[i].instructions.push(instr);\n        }\n    }\n\n    terminate() {\n        // Let matches, and thus kept states, be garbage collected\n        this.matches = null;\n    }\n}\n\nclass NonReplacingHashMap {\n    constructor(equivFn:Function, hashFn:Function, bucketCount:number = 1000) {\n        this.equiv = equivFn;\n        this.hash = hashFn;\n        this.coll = new Array(bucketCount);\n        this.length = 0;\n    }\n\n    bucketFind(bucket, obj) {\n        for (let i = 0; i < bucket.length; i++) {\n            if (this.equiv ? this.equiv(bucket[i].key, obj) : bucket[i].key == obj) {\n                return bucket[i].val;\n            }\n        }\n        return undefined;\n    }\n\n    // If val is not provided, it defaults to true\n    // Unlike a regular map, this will NOT replace existing keys!\n    push(obj, val = undefined) {\n        if (!val) {\n            val = true;\n        }\n        const hashCode = this.hash ? (this.hash(obj) % this.coll.length) : obj;\n        let bucket = this.coll[hashCode];\n        if (!bucket) {\n            this.coll[hashCode] = [{key: obj, val: val}];\n        } else {\n            if (this.bucketFind(bucket, obj) !== undefined) {\n                return false;\n            } else {\n                bucket.push({key: obj, val: val});\n            }\n        }\n        this.length++;\n        return true;\n    }\n\n    get(obj) {\n        if (this.length == 0) {\n            return undefined;\n        }\n        const hashCode = this.hash ? (this.hash(obj) % this.coll.length) : obj;\n        let bucket = this.coll[hashCode];\n        if (!bucket) {\n            return undefined;\n        }\n        return this.bucketFind(bucket, obj);\n    }\n\n    clear() {\n        for (let i = 0; i < this.coll.length; i++) {\n            //todo: generate less garbage?\n            this.coll[i] = null;\n        }\n        this.length = 0;\n    }\n\n    contains(obj) {\n        if (this.length == 0) {\n            return false;\n        }\n        const hashCode = this.hash ? (this.hash(obj) % this.coll.length) : obj;\n        let bucket = this.coll[hashCode];\n        if (!bucket) {\n            return false;\n        }\n        return this.bucketFind(bucket, obj) !== undefined;\n    }\n}\n\nfunction hashInt(h, int32) {\n    h += (int32) | 0;\n    h += (h << 10) | 0;\n    h ^= (h >> 6) | 0;\n    h += ((int32 >> 8)) | 0;\n    h += (h << 10) | 0;\n    h ^= (h >> 6) | 0;\n    h += ((int32 >> 16)) | 0;\n    h += (h << 10) | 0;\n    h ^= (h >> 6) | 0;\n    h += ((int32 >> 24)) | 0;\n    h += (h << 10) | 0;\n    h ^= (h >> 6) | 0;\n    return h;\n}\nfunction finalizeHash(h:number):number {\n    h += (h << 3) | 0;\n    h ^= (h >> 11) | 0;\n    h += (h << 15) | 0;\n    return h;\n}\nfunction hashNumbers(...numbers:Array<Number>):number {\n    let h = 0;\n    for (let i = 0; i < numbers.length; i++) {\n        h = hashInt(h, numbers[i]);\n    }\n    return finalizeHash(h);\n}\n\ntype\nMatchInstruction = {type: \"start\" | \"end\", target: string | number, index: number} |\n    {type: \"state\", index: number, state: any};\ntype\nMatch = {priority: number, instructions: Array < MatchInstruction >};\n\nconst matchEquivFn = function (a:Match, b:Match) {\n    if (a.instructions.length != b.instructions.length) {\n        return false;\n    }\n    for (let i = 0; i < a.instructions.length; i++) {\n        if (a[i].type != b[i].type || a[i].index != b[i].index || a[i].target != b[i].target) {\n            return false;\n        }\n    }\n    return true;\n}\nconst matchHashFn = function (a:Match) {\n    return hashNumbers(a.instructions.length);\n}\n\nfunction cloneMatch(m:Match):Match {\n    return {\n        priority: m.priority,\n        instructions: m.instructions.slice()\n    };\n}\n\nclass NonShrinkingArray {\n    constructor() {\n        this.array = [];\n        this.length = 0;\n    }\n\n    push(obj) {\n        this.array[this.length] = obj;\n        this.length++;\n    }\n\n    clear() {\n        this.length = 0;\n    }\n\n    get first():any {\n        if (this.length == 0) {\n            return undefined;\n        }\n        return this.array[0];\n    }\n\n    get(i:number):any {\n        if (i < 0 || i >= this.length) {\n            return undefined;\n        }\n        return this.array[i];\n    }\n}\n\n// We know a priori that the number of priority levels is relatively small\nclass PriorityQueue {\n    constructor(pfn:Function, equivFn:Function, hashFn:Function) {\n        this.queues = [];\n        this.priorityFunction = pfn;\n        this.length = 0;\n        if (equivFn || hashFn) {\n            this.members = new NonReplacingHashMap(equivFn, hashFn);\n        } else {\n            this.members = undefined;\n        }\n        this.clear();\n    }\n\n    // We also know a priori that duplicates will be detected externally if there is no equivFn/hashFn\n    push(obj) {\n        const idx = this.priorityFunction(obj);\n        if (this.members) {\n            if (this.members.contains(obj)) {\n                return false;\n            }\n            this.members.push(obj);\n        }\n        if (!(idx in this.queues)) {\n            this.queues[idx] = [obj];\n        } else {\n            this.queues[idx].push(obj);\n        }\n        if (idx < this.lowestPriority) {\n            this.lowestPriority = idx;\n        }\n        if (idx > this.highestPriority) {\n            this.highestPriority = idx;\n        }\n        this.length++;\n        return true;\n    }\n\n    shift():any {\n        if (this.lowestPriority >= Infinity || this.length == 0) {\n            return null;\n        }\n        const q = this.queues[this.lowestPriority];\n        // Within a priority level, we want the _reverse_ order of addition\n        const result = q.pop();\n        if (q.length == 0) {\n            delete this.queues[this.lowestPriority];\n            if (this.highestPriority <= this.lowestPriority) {\n                this.lowestPriority = Infinity;\n                this.highestPriority = -Infinity;\n            } else {\n                while (!(this.queues[this.lowestPriority]) && this.lowestPriority < this.highestPriority) {\n                    this.lowestPriority++;\n                }\n            }\n        }\n        this.length--;\n        return result;\n    }\n\n    get first():any {\n        if (this.length == 0) {\n            return undefined;\n        }\n        return this.queues[this.lowestPriority][0];\n    }\n\n    clear() {\n        //todo: generate less garbage\n        this.queues = [];\n        this.lowestPriority = Infinity;\n        this.highestPriority = -Infinity;\n        this.length = 0;\n        if (this.members) {\n            this.members.clear();\n        }\n    }\n}\n\nconst LIVESET_CLEAR_INTERVAL = 100;\n\nclass PlayspecResult {\n    constructor(config:{spec:Playspec, preserveStates:boolean},\n                state:{trace:Trace<State>, threads:Array<Thread>, maxThreadID:number},\n                match:PlayspecMatchResult) {\n        this.config = config;\n        this.state = state;\n        if (!this.state || !this.state.queue) {\n            this.state = {\n                // We can use plain arrays for the priority queue for now, since we know threads will be added\n                // in priority order. This also means we never shift, but increment i going up through the queue.\n                queue: new NonShrinkingArray(),\n                nextQueue: new NonShrinkingArray(),\n                // This NonReplacingHashMap will have number keys so it can use default hash/equiv\n                liveSet: new NonReplacingHashMap(null, null),\n                maxThreadID: 0,\n                // We start at -1 since the initial actions of the initial thread\n                // should happen before the trace reaches index 0. This mainly ensures that\n                // capture groups line up correctly.\n                index: -1,\n                pastEnd: false,\n                trace: this.config.spec.traceAPI.start(state.trace),\n                // Same here for matches, always added in priority order -- but can use a regular array\n                matchQueue: new PriorityQueue((m:Match) => m.priority),\n                matchSet: new NonReplacingHashMap(matchEquivFn, matchHashFn),\n                lastMatchPriority: 0\n            };\n            let initThread = new Thread(0, 0, 0, [{priority: 0, instructions: []}]);\n            this.enqueueThread(initThread);\n            //swap queues\n            const temp = this.state.queue;\n            this.state.queue = this.state.nextQueue;\n            this.state.nextQueue = temp;\n            //clear live and match sets\n            this.state.liveSet.clear();\n            this.state.matchSet.clear();\n            //move index to start\n            this.state.index = 0;\n        }\n        this.match = match;\n    }\n\n    get start() {\n        return this.match ? this.match.start : -1;\n    }\n\n    get end() {\n        return this.match ? this.match.end : -1;\n    }\n\n    get states() {\n        return this.match ? this.match.states : undefined;\n    }\n\n    hasReadyMatch():boolean {\n        if (!this.state.matchQueue.length) {\n            return false;\n        }\n        if (!this.state.queue.length) {\n            return true;\n        }\n        return this.state.matchQueue.first.priority <= this.state.queue.first.priority\n    }\n\n    enqueueThread(thread) {\n        // Unlike Cox's implementation, we can only do duplicate checking for threads that are about to park.\n        // So we'll do some redundant jumping/splitting/matching, but since we need to merge threads it can't\n        // really be avoided.\n        const instr = this.config.spec.program[thread.pc];\n        switch (instr.type) {\n            case \"jump\":\n                thread.pc = instr.target;\n                this.enqueueThread(thread);\n                return;\n            case \"split\":\n                this.state.maxThreadID++;\n                thread.pc = instr.left;\n                //match sharing: Be sure thread1 knows thread2 is using its matches.\n                //thread.sharedMatches = true;\n                const thread2 = new Thread(this.state.maxThreadID, instr.right, thread.priority + 1, thread.matches);\n                this.enqueueThread(thread);\n                this.enqueueThread(thread2);\n                return;\n            case \"start\":\n                thread.pushMatchInstruction({\n                    type: \"start\",\n                    // +1 because the _current_ trace index just matched previously, so we don't want to include it in\n                    // the match that starts with the _next_ character.\n                    index: this.state.index + 1,\n                    target: instr.group\n                });\n                thread.pc++;\n                this.enqueueThread(thread);\n                return;\n            case \"end\":\n                thread.pushMatchInstruction({\n                    type: \"end\",\n                    // +1 for same reason as above.\n                    index: this.state.index + 1,\n                    target: instr.group\n                });\n                thread.pc++;\n                this.enqueueThread(thread);\n                return;\n            case \"match\":\n                // Add matches to queue\n                for (let i = 0; i < thread.matches.length; i++) {\n                    if (thread.matches[i].priority >= thread.priority) {\n                        // If it's a novel match...\n                        if (this.state.matchSet.push(thread.matches[i])) {\n                            // Add it to the queue!\n                            this.state.matchQueue.push(thread.matches[i]);\n                        }\n                    }\n                }\n                //drop thread, its work is done\n                thread.terminate();\n                return;\n            case \"check\":\n                // check live set, then add to queue\n                const hash = thread.hash();\n                let live = this.state.liveSet.get(hash);\n                if (!live) {\n                    let threadList = new NonShrinkingArray();\n                    threadList.push(thread);\n                    this.state.liveSet.push(hash, {index: this.state.index, threads: threadList});\n                } else if (live.index != this.state.index) {\n                    live.index = this.state.index;\n                    live.threads.clear();\n                    live.threads.push(thread);\n                } else {\n                    //maybe present\n                    for (let i = 0; i < live.threads.length; i++) {\n                        if (live.threads.get(i).equals(thread)) {\n                            live.threads.get(i).mergeThread(thread);\n                            // Drop the merged-in thread, no more work to do\n                            thread.terminate();\n                            return;\n                        }\n                    }\n                }\n                //not present: add stuck thread to queue.\n                this.state.nextQueue.push(thread);\n                return;\n            //todo: case fork, join, joined-left, joined-right\n            // joined-left and joined-right will need to handle merging!\n            default:\n                throw new Error(\"Unrecognized instruction type ${instr.type}\");\n        }\n    }\n\n    prettifyMatch(m:Match) {\n        let groups = [];\n        let liveGroups = {};\n        for (let i = 0; i < m.instructions.length; i++) {\n            const instr = m.instructions[i];\n            switch (instr.type) {\n                case \"start\":\n                    let newG = {group: instr.target, start: instr.index, end: Infinity};\n                    if (this.config.preserveStates) {\n                        newG.states = [];\n                    }\n                    groups.push(newG);\n                    if (liveGroups[newG.group]) {\n                        throw new Error(\"Duplicate capture group\");\n                    }\n                    liveGroups[newG.group] = newG;\n                    break;\n                case \"state\":\n                    let openGroups = Object.getOwnPropertyNames(liveGroups);\n                    for (let gi = 0; gi < openGroups.length; gi++) {\n                        let continuedG = liveGroups[openGroups[gi]];\n                        continuedG.states.push(instr.state);\n                    }\n                    break;\n                case \"end\":\n                    let finishedG = liveGroups[instr.target];\n                    finishedG.end = instr.index;\n                    delete liveGroups[instr.target];\n                    break;\n            }\n        }\n        let openGroups = Object.getOwnPropertyNames(liveGroups);\n        if (openGroups.length) {\n            throw new Error(`Open capture groups: ${openGroups.join(\",\")}`);\n        }\n        let rootGroup = groups.shift();\n        let rootMatch = {start:rootGroup.start, end:rootGroup.end, subgroups:groups};\n        if(this.config.preserveStates) {\n            rootMatch.states = rootGroup.states;\n        }\n        return rootMatch;\n    }\n\n    next():PlayspecResult {\n        if (!this.state) {\n            throw new Error(\"Don't call next() on the same PlayspecResult twice!\");\n        }\n        while (!this.hasReadyMatch() && this.state.queue.length) {\n            const state = this.config.spec.traceAPI.currentState(this.state.trace);\n            let copiedState = undefined;\n            const limit = this.state.queue.length;\n            let lastPriority = 0;\n            for (let t = 0; t < this.state.queue.length; t++) {\n                if (t >= limit) {\n                    throw new Error(\"The thread queue should never grow during a single trace state!\");\n                }\n                if (t.priority < lastPriority) {\n                    throw new Error(\"Decreasing priority!\");\n                }\n                let thread = this.state.queue.get(t);\n                const instr = this.config.spec.program[thread.pc];\n                switch (instr.type) {\n                    case \"check\":\n                        const checkResult = this.config.spec.check(\n                            this.state.trace,\n                            state,\n                            this.state.index,\n                            instr.formula\n                        );\n                        if (checkResult) {\n                            thread.pc++;\n                            if (thread.hasOpenMatch) {\n                                if (this.config.preserveStates) {\n                                    if (!copiedState) {\n                                        copiedState = this.config.spec.traceAPI.copyCurrentState ?\n                                            this.config.spec.traceAPI.copyCurrentState() :\n                                            state;\n                                    }\n                                    thread.pushMatchInstruction({\n                                        type: \"state\",\n                                        index: this.state.index,\n                                        state: copiedState\n                                    });\n                                }\n                            }\n                            this.enqueueThread(thread);\n                        } else { //otherwise drop the thread on the floor\n                            thread.terminate();\n                        }\n                        break;\n                    default:\n                        throw new Error(\"Thread should be parked on a check.\");\n                }\n            }\n            //swap queues and clear old queue\n            let temp = this.state.queue;\n            this.state.queue = this.state.nextQueue;\n            temp.clear();\n            this.state.nextQueue = temp;\n            //maybe clear liveset (don't want to do it every time, so short specs/strings can avoid memory churn)\n            if ((this.state.index % LIVESET_CLEAR_INTERVAL) == 0) {\n                this.state.liveSet.clear();\n            }\n            //definitely clear matchset (later matches won't ever be equivalent to matches from this time)\n            this.state.matchSet.clear();\n            //advance, unless already at end\n            if (this.config.spec.traceAPI.isAtEnd(this.state.trace)) {\n                //wipe out queue, no more trace to match!\n                this.state.queue.clear();\n                break;\n            }\n            this.config.spec.traceAPI.advanceState(this.state.trace);\n            this.state.index++;\n        }\n        if (this.hasReadyMatch()) {\n            // Also removes first match from queue!\n            const match = this.state.matchQueue.shift();\n            if (this.state.lastMatchPriority > match.priority) {\n                throw new Error(\"Matches popped out of order!\");\n            }\n            this.state.lastMatchPriority = match.priority;\n            const prettyMatch = this.prettifyMatch(match);\n            const nextState = this.state;\n            this.state = undefined;\n            return new PlayspecResult(\n                this.config,\n                nextState,\n                prettyMatch\n            );\n        } // Otherwise, we're out of queue or trace and have nowhere to go\n        this.state = undefined;\n        return null;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./playspec.js\n **/"],"sourceRoot":""}