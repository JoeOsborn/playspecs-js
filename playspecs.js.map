{"version":3,"sources":["webpack:///webpack/bootstrap df06acdc027de07138fe","webpack:///./playspecs.js","webpack:///./parser.js","webpack:///./compiler.js"],"names":[],"mappings":"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","file":"playspecs.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap df06acdc027de07138fe\n **/","/* @flow */\n\n//const Parser = require(\"parser.js\").Parser;\n//\n//var p = new Parser();\n//\n//console.log(p);\n//\n//export Parser;\n\nimport * as Parser from \"./parser\";\nimport * as Compiler from \"./compiler\";\n\nexports.Parser = Parser;\nexports.Compiler = Compiler;\n\n\n/** WEBPACK FOOTER **\n ** ./playspecs.js\n **/","/* @flow */\n\nexport const tokenTypes:{ [key: string]: string } = {\n    WHITESPACE: \" \",\n    CONCATENATION: \",\",\n    // Bounding integers are tokenized as part of the dots to minimize potential conflicts with user-provided syntax.\n    DOTS_GREEDY: \"...\",\n    DOTS_RELUCTANT: \"..\",\n    DOTS_OMEGA: \"***\",\n    LEFT_PAREN: \"(\",\n    RIGHT_PAREN: \")\",\n    ALTERNATION: \";\",\n    INTERSECTION: \"^\",\n    AND: \"&\",\n    OR: \"|\",\n    NOT: \"not\",\n    START: \"start\",\n    END: \"end\",\n    TRUE: \"true\",\n    FALSE: \"false\",\n    ERROR: \"error\"\n};\n\nexport const parseTypes:{ [key: string]: string } = {\n    OMEGA: tokenTypes.DOTS_OMEGA,\n    REPETITION: tokenTypes.DOTS_GREEDY,\n    CONCATENATION: tokenTypes.CONCATENATION,\n    GROUP: tokenTypes.LEFT_PAREN,\n    ALTERNATION: tokenTypes.ALTERNATION,\n    INTERSECTION: tokenTypes.INTERSECTION,\n    AND: tokenTypes.AND,\n    OR: tokenTypes.OR,\n    NOT: tokenTypes.NOT,\n    START: tokenTypes.START,\n    END: tokenTypes.END,\n    TRUE: tokenTypes.TRUE,\n    FALSE: tokenTypes.FALSE,\n    ERROR: tokenTypes.ERROR\n};\n\ntype MatchResult = Array < string >;\n\ntype TokenDefinition = Array < {\n        type: string,\n        match: string | Array < string > | RegExp,\n        value? : ((mr:MatchResult) => any),\n        tightness? : number,\n        startParse? : ((p:Parser, t:Token) => ParseTree),\n        extendParse? : ((p:Parser, pt:ParseTree, t:Token) => ParseTree)\n    } >;\n\ntype Token = {\n    type: string,\n    value: any,\n    // A bit redundant, but makes defining generic startParse/extendParse functions easier.\n    tightness: number,\n    range: {start: number, end: number}\n};\n\ntype ParseTree = {\n    type: string,\n    value: any,\n    children: Array < ParseTree >,\n    range: {start: number, end: number}\n};\n\ntype TokenStream = {\n    string: string,\n    tokens: Array < Token >,\n    position: number,\n    errors: Array < number >\n};\n\nexport const constantValue = function(c:any) {\n    return function(_mr:MatchResult) { return c; }\n};\n\nexport const parseValue = function (parser:Parser, token:Token) {\n    return parser.node(token.type, token.value);\n};\n\nexport const parseInfixR = function (parser:Parser, left:ParseTree, token:Token) {\n    let children = [left];\n    children.push(parser.parseExpression(token.tightness-1));\n    return parser.node(token.type, token.value, children);\n};\n\nexport const parseInfixRPropositional = function (parser:Parser, left:ParseTree, token:Token) {\n    if (!isPropositional(left)) {\n        return parser.error(\"Left hand side of token must be propositional\", token, left);\n    }\n    let children = [left];\n    const right = parser.parseExpression(token.tightness-1);\n    if (!isPropositional(right)) {\n        return parser.error(\"Right hand side of token must be propositional\", token, right);\n    }\n    children.push(right);\n    return parser.node(token.type, token.value, children);\n};\n\nexport const BOUND_INFINITE = \"$END\";\n\nexport const standardTokens:Array<TokenSchema> = [\n    {\n        type: tokenTypes.WHITESPACE,\n        match: /^\\s+/\n    },\n    {\n        type: tokenTypes.CONCATENATION,\n        match: [tokenTypes.CONCATENATION],\n        tightness: 100,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.DOTS_GREEDY,\n        match: /^([0-9]*)\\s*\\.\\.\\.\\s*([0-9]*)/,\n        value: function (matchResult:MatchResult):any {\n            return {\n                greedy: true,\n                lowerBound: matchResult[1] ? parseInt(matchResult[1]) : 0,\n                upperBound: matchResult[2] ? parseInt(matchResult[2]) : BOUND_INFINITE\n            };\n        },\n        tightness: 110,\n        startParse: function(parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.start;\n            return parser.node(parseTypes.REPETITION, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.REPETITION, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.DOTS_RELUCTANT,\n        match: /^([0-9]*)\\s*\\.\\.\\s*([0-9]*)/,\n        tightness: 110,\n        value: function (matchResult:MatchResult) {\n            return {\n                greedy: false,\n                lowerBound: matchResult[1] ? parseInt(matchResult[1]) : 0,\n                upperBound: matchResult[2] ? parseInt(matchResult[2]) : BOUND_INFINITE\n            };\n        },\n        startParse: function(parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.start;\n            return parser.node(parseTypes.REPETITION, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.REPETITION, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.DOTS_OMEGA,\n        match: [tokenTypes.DOTS_OMEGA],\n        tightness: 110,\n        startParse: function(parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.end;\n            return parser.node(parseTypes.OMEGA, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.OMEGA, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.LEFT_PAREN,\n        match: [tokenTypes.LEFT_PAREN],\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            //parse an expression at RBP 0, then eat a )\n            const expr = parser.parseExpression(0);\n            if(parser.currentToken().type != tokenTypes.RIGHT_PAREN) {\n                return parser.error(\"Missing right parenthesis\", token, expr);\n            }\n            return parser.node(parseTypes.GROUP, token.value, [expr]);\n        }\n    },\n    {\n        type: tokenTypes.RIGHT_PAREN,\n        match: [tokenTypes.RIGHT_PAREN]\n    },\n    {\n        type: tokenTypes.ALTERNATION,\n        match: [tokenTypes.ALTERNATION],\n        tightness: 60,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.INTERSECTION,\n        match: [tokenTypes.INTERSECTION],\n        tightness: 50,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.AND,\n        match: [tokenTypes.AND],\n        tightness: 200,\n        extendParse: parseInfixRPropositional\n    },\n    {\n        type: tokenTypes.OR,\n        match: [tokenTypes.OR],\n        tightness: 210,\n        extendParse: parseInfixRPropositional\n    },\n    {\n        type: tokenTypes.NOT,\n        match: [tokenTypes.NOT],\n        tightness: 220,\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const phi = parser.parseExpression(token.tightness);\n            if (!isPropositional(phi)) {\n                return parser.error(\"NOT may only negate propositional state formulae\", token, phi);\n            }\n            return parser.node(token.type, token.value, [phi]);\n        }\n    },\n    {\n        type: tokenTypes.START,\n        match: [tokenTypes.START],\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.END,\n        match: [tokenTypes.END],\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.TRUE,\n        match: [tokenTypes.TRUE],\n        value: constantValue(true),\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.FALSE,\n        match: [tokenTypes.FALSE],\n        value: constantValue(false),\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.ERROR,\n        match: /^\\S+/,\n        startParse: parseValue\n    }\n];\n\nconst customTightnessOffset = 300;\n\nconst ERROR = \"ERROR\";\n\nfunction isString(s:any):bool {\n    return typeof s === 'string' || s instanceof String;\n}\n\nexport function isCustom(p:ParseTree):bool {\n    for(var k in parseTypes) {\n        if(parseTypes[k] == p.type) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function isPropositional(p:ParseTree):bool {\n    return isCustom(p) ||\n        p.type == parseTypes.AND ||\n        p.type == parseTypes.OR ||\n        p.type == parseTypes.NOT ||\n        p.type == parseTypes.START ||\n        p.type == parseTypes.END ||\n        (p.type == parseTypes.GROUP &&\n        p.children.every(function(c) {\n            return isPropositional(c);\n        }));\n}\n\nexport class Parser {\n    constructor(context) {\n        this.tokenDefinitions = [];\n        this.tokensByType = {};\n        this.parseErrors = [];\n        const customTokens = context.tokens || [];\n        const tokens = customTokens.concat(standardTokens);\n        for (let ti = 0; ti < tokens.length; ti++) {\n            const input = tokens[ti];\n            const tightness = input.tightness || 0;\n            const defn = {\n                type: input.type,\n                match: isString(input.match) ? [input.match] : input.match,\n                value: input.value || function (mr) {\n                    return mr[0];\n                },\n                tightness: ti < customTokens.length ? tightness+customTightnessOffset : tightness,\n                startParse: input.startParse || function (parser, token) {\n                    return parser.error(\"Can't start a parse tree with this token\", token);\n                },\n                extendParse: input.extendParse || function (parser, token, parseTree) {\n                    return parser.error(\"Can't extend a parse tree with this token\", token, parseTree);\n                }\n            };\n            this.tokenDefinitions.push(defn);\n            this.tokensByType[defn.type] = defn;\n        }\n        this.resetStream();\n    }\n\n    node(type:string, value:any = undefined, children:Array<ParseTree> = []):ParseTree {\n        return {type, value, children, range: {start: -1, end: -1}};\n    }\n\n    error(msg:string, token:Token, tree:ParseTree = undefined):ParseTree {\n        const err = this.node(ERROR, {message: msg, token, tree});\n        this.parseErrors.push(err);\n        return err;\n    }\n\n    tokenize(str:string):TokenStream {\n        let result:Array<Token> = [];\n        let errors:Array<number> = [];\n        let substring:string = str;\n        let index:number = 0;\n        while (substring.length) {\n            for (let ti = 0; ti < this.tokenDefinitions.length; ti++) {\n                const tokenDefinition = this.tokenDefinitions[ti];\n                const match = tokenDefinition.match;\n                let matchResult = null;\n                if (match instanceof RegExp) {\n                    matchResult = match.exec(substring);\n                } else if (Array.isArray(match)) {\n                    for (let mi = 0; mi < match.length; mi++) {\n                        const candidate = match[mi];\n                        if (substring.substr(0, candidate.length) == candidate) {\n                            matchResult = [candidate];\n                            matchResult.index = 0;\n                        }\n                    }\n                }\n                if (matchResult && matchResult.index == 0) {\n                    const matchLength = matchResult[0].length;\n                    substring = substring.substr(matchResult[0].length);\n                    const oldIndex = index;\n                    index += matchLength;\n                    if (tokenDefinition.type !== tokenTypes.WHITESPACE) {\n                        if (tokenDefinition.type === tokenTypes.ERROR) {\n                            errors.push(result.length);\n                        }\n                        result.push({\n                            type: tokenDefinition.type,\n                            value: tokenDefinition.value(matchResult),\n                            tightness: tokenDefinition.tightness,\n                            range: {start: oldIndex, end: index}\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        return {string: str, tokens: result, position: 0, errors: errors};\n    }\n\n    resetStream():void {\n        this.stream = {string: \"\", tokens: [], position: 0, errors: []};\n    }\n\n    charPosition():number {\n        return this.currentToken() ? this.currentToken().range.start : this.stream.string.length;\n    }\n\n    remainder():string {\n        const end = this.charPosition();\n        return this.stream.string.substr(end);\n    }\n\n    currentToken():Token {\n        return this.stream.tokens[this.stream.position];\n    }\n\n    advance():void {\n        this.stream.position++;\n    }\n\n    parse(str:string):{tree:ParseTree, errors:Array<ParseTree>, remainder:string} {\n        this.stream = this.tokenize(str);\n        this.parseErrors = [];\n        const tree = this.parseExpression(0);\n        var result = {tree, errors: this.parseErrors, remainder: this.remainder()};\n        this.parseErrors = [];\n        this.resetStream();\n        return result;\n    }\n\n    parseExpression(tightness:number):ParseTree {\n        let token = this.currentToken();\n        let tokenDef = this.tokensByType[token.type];\n        const start = token.range.start;\n        this.advance();\n        let tree = tokenDef.startParse(this, token);\n        tree.range.start = start;\n        tree.range.end = this.charPosition();\n        if (tree.type == ERROR) {\n            return tree;\n        }\n        token = this.currentToken();\n        while (token && tightness < token.tightness) {\n            tokenDef = this.tokensByType[token.type];\n            this.advance();\n            let newTree = tokenDef.extendParse(this, tree, token);\n            newTree.range.start = tree.range.start;\n            newTree.range.end = this.charPosition();\n            if (newTree.type == ERROR) {\n                return newTree;\n            }\n            tree = newTree;\n            token = this.currentToken();\n        }\n        return tree;\n    }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./parser.js\n **/","/* @flow */\n\nimport {parseTypes, isPropositional, BOUND_INFINITE} from \"./parser\";\n\ntype\nInstruction =\n    {type: \"check\", formula: ParseTree, index: number} |\n    {type: \"jump\", target: number, index: number} |\n    {type: \"split\", left: number, right: number, index: number} |\n    {type: \"match\", index: number};\ntype\nProgram = Array < Instruction >;\n\nexport class Compiler {\n    constructor(_ctx) {\n\n    }\n\n    compileTree(tree:ParseTree, idx:number):Program {\n        if (tree.type == parseTypes.GROUP) {\n            // TODO: submatch saving\n            return this.compileTree(tree.children[0], idx);\n        }\n        if (isPropositional(tree)) {\n            console.log(\"tree \" + JSON.stringify(tree) + \":\" + tree.type + \" is propositional\");\n            return [{type: \"check\", formula: tree, index: idx}];\n        }\n        if (tree.type == parseTypes.CONCATENATION) {\n            const aIdx = idx;\n            const a = this.compileTree(tree.children[0], aIdx);\n            const bIdx = idx + a.length;\n            const b = this.compileTree(tree.children[1], bIdx);\n            return a.concat(b);\n        }\n        if (tree.type == parseTypes.ALTERNATION) {\n            // branch; but need to compile left first.\n            // left:\n            const aIdx = idx + 1;\n            const left = this.compileTree(tree.children[0], aIdx);\n            const bIdx = aIdx + left.length + 1; // Leave room for jump after left\n            // now we can define branch, which goes before left:\n            const branch = [{type: \"split\", left: aIdx, right: bIdx, index: idx}];\n            // right:\n            const right = this.compileTree(tree.children[1], bIdx);\n            const cIdx = bIdx + right.length;\n            const jump = [{type: \"jump\", target: cIdx, index: aIdx + left.length}];\n            return branch.concat(left).concat(jump).concat(right);\n        }\n        if (tree.type == parseTypes.INTERSECTION) {\n            // TODO: intersection\n        }\n        if (tree.type == parseTypes.REPETITION) {\n            const greedy = tree.value.greedy;\n            const min = tree.value.lowerBound;\n            const phi = tree.children[0];\n            // min repetitions of phi\n            let preface = [];\n            for (let i = 0; i < min; i++) {\n                const phiPgm = this.compileTree(phi, idx);\n                idx += phiPgm.length;\n                preface.push(...phiPgm);\n            }\n            if (tree.value.upperBound != BOUND_INFINITE) {\n                // M-N repetitions of (phi?)\n                const max = tree.value.upperBound;\n                let optionals = [];\n                let targets = [];\n                for (let i = min; i < max; i++) {\n                    // make room for split li,lZ\n                    idx = idx + 1;\n                    // store jump target li in targets\n                    targets.push(idx);\n                    const phiPgm = this.compileTree(phi, idx);\n                    // make room for phiPgm\n                    idx += phiPgm.length;\n                    optionals.push(phiPgm);\n                }\n                //idx is now just past the end of all the \"optionals\".\n                let repetition = [];\n                for (let i = 0; i < optionals.length; i++) {\n                    repetition.push({\n                        type: \"split\",\n                        left: (greedy ? targets[i] : idx),\n                        right: (greedy ? idx : targets[i]),\n                        index: targets[i] - 1\n                    });\n                    repetition.push(...(optionals[i]));\n                }\n                return preface.concat(repetition);\n            } else {\n                // A: split B, C; but must compile B first to get label for C\n                const aIdx = idx;\n                // make room for the split\n                const bIdx = aIdx + 1;\n                // then put in B\n                const b = this.compileTree(phi, bIdx);\n                const jump = [{type: \"jump\", target: aIdx, index: bIdx + b.length}];\n                // then label C\n                const cIdx = bIdx + b.length + 1;\n                const branch = [{\n                    type: \"split\",\n                    left: (greedy ? bIdx + 1 : cIdx),\n                    right: (greedy ? cIdx : bIdx + 1),\n                    index: idx\n                }];\n                return preface.concat(branch).concat(b).concat(jump);\n            }\n        }\n        throw new Error(\"Can't compile \" + JSON.stringify(tree));\n        return [];\n    }\n\n    compile(tree:ParseTree):Program {\n        // We preface every program with \"true ..\" so that all Playspecs are effectively start-anchored.\n        // This is as per https://swtch.com/~rsc/regexp/regexp2.html\n        const preface = [\n            {type: \"split\", left: 2, right: 1, index: 0},\n            {\n                type: \"check\",\n                formula: {\n                    type: parseTypes.TRUE,\n                    value: true,\n                    children: [],\n                    range: {start: 0, end: 0}\n                },\n                index: 1\n            },\n            {type: \"jump\", target: 0, index: 2}\n        ];\n        const body = this.compileTree(tree, preface.length);\n        const result = preface.concat(body).concat([{type: \"match\", index: preface.length + body.length}]);\n        if (!this.validate(result)) {\n            throw new Error(\n                \"Error compiling tree \" + JSON.stringify(tree) + \" into result \" + JSON.stringify(result)\n            );\n        }\n        return result;\n    }\n\n    validate(pgm:Program):bool {\n        // todo: validate programs against some basic sanity checks.\n        //ensure each instruction's index is its index in pgm\n        //ensure no split or jump goes beyond end of program\n        //...\n        return true;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./compiler.js\n **/"],"sourceRoot":""}