{"version":3,"sources":["webpack:///webpack/bootstrap 62244ec5122c35179485","webpack:///./playspecs.js","webpack:///./parser.js","webpack:///./compiler.js","webpack:///./playspec.js"],"names":[],"mappings":"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","file":"playspecs.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 62244ec5122c35179485\n **/","/* @flow */\n\n//const Parser = require(\"parser.js\").Parser;\n//\n//var p = new Parser();\n//\n//console.log(p);\n//\n//export Parser;\n\nimport * as ParserExports from \"./parser\";\nimport {default as CompilerExports} from \"./compiler\";\nimport {default as PlayspecExports} from \"./playspec\";\n\nexport const Parser = ParserExports;\nexport const Compiler = CompilerExports;\nexport const Playspec = PlayspecExports;\n\n\n/** WEBPACK FOOTER **\n ** ./playspecs.js\n **/","/* @flow */\n\nexport const tokenTypes:{ [key: string]: string } = {\n    WHITESPACE: \" \",\n    CONCATENATION: \",\",\n    // Bounding integers are tokenized as part of the dots to minimize potential conflicts with user-provided syntax.\n    DOTS_GREEDY: \"...\",\n    DOTS_RELUCTANT: \"..\",\n    DOTS_OMEGA: \"***\",\n    LEFT_PAREN: \"(\",\n    RIGHT_PAREN: \")\",\n    ALTERNATION: \";\",\n    INTERSECTION: \"^\",\n    AND: \"&\",\n    OR: \"|\",\n    NOT: \"not\",\n    START: \"start\",\n    END: \"end\",\n    TRUE: \"true\",\n    FALSE: \"false\",\n    ERROR: \"error\"\n};\n\nexport const parseTypes:{ [key: string]: string } = {\n    OMEGA: tokenTypes.DOTS_OMEGA,\n    REPETITION: tokenTypes.DOTS_GREEDY,\n    CONCATENATION: tokenTypes.CONCATENATION,\n    GROUP: tokenTypes.LEFT_PAREN,\n    ALTERNATION: tokenTypes.ALTERNATION,\n    INTERSECTION: tokenTypes.INTERSECTION,\n    AND: tokenTypes.AND,\n    OR: tokenTypes.OR,\n    NOT: tokenTypes.NOT,\n    START: tokenTypes.START,\n    END: tokenTypes.END,\n    TRUE: tokenTypes.TRUE,\n    FALSE: tokenTypes.FALSE,\n    ERROR: tokenTypes.ERROR\n};\n\ntype\nMatchResult = Array < string >;\n\ntype\nTokenDefinition = Array < {\n        type: string,\n        match: string | Array < string > | RegExp,\n        value? : ((mr:MatchResult) => any),\n        tightness? : number,\n        startParse? : ((p:Parser, t:Token) => ParseTree),\n        extendParse? : ((p:Parser, pt:ParseTree, t:Token) => ParseTree)\n    } >;\n\ntype\nToken = {\n    type: string,\n    value: any,\n    // A bit redundant, but makes defining generic startParse/extendParse functions easier.\n    tightness: number,\n    range: {start: number, end: number}\n};\n\ntype\nParseTree = {\n    type: string,\n    value: any,\n    children: Array < ParseTree >,\n    range: {start: number, end: number}\n};\n\ntype\nTokenStream = {\n    string: string,\n    tokens: Array < Token >,\n    position: number,\n    errors: Array < number >\n};\n\nexport const constantValue = function (c:any) {\n    return function (_mr:MatchResult) {\n        return c;\n    }\n};\n\nexport const parseValue = function (parser:Parser, token:Token) {\n    return parser.node(token.type, token.value);\n};\n\nexport const parseInfixR = function (parser:Parser, left:ParseTree, token:Token) {\n    let children = [left];\n    children.push(parser.parseExpression(token.tightness - 1));\n    return parser.node(token.type, token.value, children);\n};\n\nexport const parseInfixRPropositional = function (parser:Parser, left:ParseTree, token:Token) {\n    if (!isPropositional(left)) {\n        return parser.error(\"Left hand side of token must be propositional\", token, left);\n    }\n    let children = [left];\n    const right = parser.parseExpression(token.tightness - 1);\n    if (!isPropositional(right)) {\n        return parser.error(\"Right hand side of token must be propositional\", token, right);\n    }\n    children.push(right);\n    return parser.node(token.type, token.value, children);\n};\n\nexport const BOUND_INFINITE = \"$END\";\n\nexport const standardTokens:Array<TokenSchema> = [\n    {\n        type: tokenTypes.WHITESPACE,\n        match: /^\\s+/\n    },\n    {\n        type: tokenTypes.CONCATENATION,\n        match: [tokenTypes.CONCATENATION],\n        tightness: 100,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.DOTS_GREEDY,\n        match: /^([0-9]*)\\s*\\.\\.\\.\\s*([0-9]*)/,\n        value: function (matchResult:MatchResult):any {\n            return {\n                greedy: true,\n                lowerBound: matchResult[1] ? parseInt(matchResult[1]) : 0,\n                upperBound: matchResult[2] ? parseInt(matchResult[2]) : BOUND_INFINITE\n            };\n        },\n        tightness: 110,\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.start;\n            return parser.node(parseTypes.REPETITION, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.REPETITION, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.DOTS_RELUCTANT,\n        match: /^([0-9]*)\\s*\\.\\.\\s*([0-9]*)/,\n        tightness: 110,\n        value: function (matchResult:MatchResult) {\n            return {\n                greedy: false,\n                lowerBound: matchResult[1] ? parseInt(matchResult[1]) : 0,\n                upperBound: matchResult[2] ? parseInt(matchResult[2]) : BOUND_INFINITE\n            };\n        },\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.start;\n            return parser.node(parseTypes.REPETITION, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.REPETITION, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.DOTS_OMEGA,\n        match: [tokenTypes.DOTS_OMEGA],\n        tightness: 110,\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const truePhi = parser.node(parseTypes.TRUE, true);\n            truePhi.range.start = token.range.start;\n            truePhi.range.end = token.range.end;\n            return parser.node(parseTypes.OMEGA, token.value, [truePhi]);\n        },\n        extendParse: function (parser:Parser, left:ParseTree, token:Token):ParseTree {\n            return parser.node(parseTypes.OMEGA, token.value, [left]);\n        }\n    },\n    {\n        type: tokenTypes.LEFT_PAREN,\n        match: [tokenTypes.LEFT_PAREN],\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            //parse an expression at RBP 0, then eat a )\n            const expr = parser.parseExpression(0);\n            if (parser.currentToken().type != tokenTypes.RIGHT_PAREN) {\n                return parser.error(\"Missing right parenthesis\", token, expr);\n            }\n            parser.advance();\n            return parser.node(parseTypes.GROUP, token.value, [expr]);\n        }\n    },\n    {\n        type: tokenTypes.RIGHT_PAREN,\n        match: [tokenTypes.RIGHT_PAREN]\n    },\n    {\n        type: tokenTypes.ALTERNATION,\n        match: [tokenTypes.ALTERNATION],\n        tightness: 60,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.INTERSECTION,\n        match: [tokenTypes.INTERSECTION],\n        tightness: 50,\n        extendParse: parseInfixR\n    },\n    {\n        type: tokenTypes.AND,\n        match: [tokenTypes.AND],\n        tightness: 200,\n        extendParse: parseInfixRPropositional\n    },\n    {\n        type: tokenTypes.OR,\n        match: [tokenTypes.OR],\n        tightness: 210,\n        extendParse: parseInfixRPropositional\n    },\n    {\n        type: tokenTypes.NOT,\n        match: [tokenTypes.NOT],\n        tightness: 220,\n        startParse: function (parser:Parser, token:Token):ParseTree {\n            const phi = parser.parseExpression(token.tightness);\n            if (!isPropositional(phi)) {\n                return parser.error(\"NOT may only negate propositional state formulae\", token, phi);\n            }\n            return parser.node(token.type, token.value, [phi]);\n        }\n    },\n    {\n        type: tokenTypes.START,\n        match: [tokenTypes.START],\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.END,\n        match: [tokenTypes.END],\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.TRUE,\n        match: [tokenTypes.TRUE],\n        value: constantValue(true),\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.FALSE,\n        match: [tokenTypes.FALSE],\n        value: constantValue(false),\n        startParse: parseValue\n    },\n    {\n        type: tokenTypes.ERROR,\n        match: /^\\S+/,\n        startParse: parseValue\n    }\n];\n\nconst customTightnessOffset = 300;\n\nconst ERROR = \"ERROR\";\n\nfunction isString(s:any):bool {\n    return typeof s === 'string' || s instanceof String;\n}\n\nexport function isCustom(p:ParseTree):bool {\n    for (var k in parseTypes) {\n        if (parseTypes[k] == p.type) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function isPropositional(p:ParseTree):bool {\n    return isCustom(p) ||\n        p.type == parseTypes.AND ||\n        p.type == parseTypes.OR ||\n        p.type == parseTypes.NOT ||\n        p.type == parseTypes.TRUE ||\n        p.type == parseTypes.FALSE ||\n        p.type == parseTypes.START ||\n        p.type == parseTypes.END ||\n        (p.type == parseTypes.GROUP &&\n        p.children.every(function (c) {\n            return isPropositional(c);\n        }));\n}\n\nexport class Parser {\n    constructor(context) {\n        this.tokenDefinitions = [];\n        this.tokensByType = {};\n        this.parseErrors = [];\n        const customTokens = context.tokens || [];\n        const tokens = customTokens.concat(standardTokens);\n        for (let ti = 0; ti < tokens.length; ti++) {\n            const input = tokens[ti];\n            const tightness = input.tightness || 0;\n            const defn = {\n                type: input.type,\n                match: isString(input.match) ? [input.match] : input.match,\n                value: input.value || function (mr) {\n                    return mr[0];\n                },\n                tightness: ti < customTokens.length ? tightness + customTightnessOffset : tightness,\n                startParse: input.startParse || function (parser, token) {\n                    return parser.error(\"Can't start a parse tree with this token\", token);\n                },\n                extendParse: input.extendParse || function (parser, token, parseTree) {\n                    return parser.error(\"Can't extend a parse tree with this token\", token, parseTree);\n                }\n            };\n            this.tokenDefinitions.push(defn);\n            this.tokensByType[defn.type] = defn;\n        }\n        this.resetStream();\n    }\n\n    node(type:string, value:any = undefined, children:Array<ParseTree> = []):ParseTree {\n        return {type, value, children, range: {start: -1, end: -1}};\n    }\n\n    error(msg:string, token:Token, tree:ParseTree = undefined):ParseTree {\n        const err = this.node(ERROR, {message: msg, token, tree});\n        this.parseErrors.push(err);\n        return err;\n    }\n\n    tokenize(str:string):TokenStream {\n        let result:Array<Token> = [];\n        let errors:Array<number> = [];\n        let substring:string = str;\n        let index:number = 0;\n        while (substring.length) {\n            for (let ti = 0; ti < this.tokenDefinitions.length; ti++) {\n                const tokenDefinition = this.tokenDefinitions[ti];\n                const match = tokenDefinition.match;\n                let matchResult = null;\n                if (match instanceof RegExp) {\n                    matchResult = match.exec(substring);\n                } else if (Array.isArray(match)) {\n                    for (let mi = 0; mi < match.length; mi++) {\n                        const candidate = match[mi];\n                        if (substring.substr(0, candidate.length) == candidate) {\n                            matchResult = [candidate];\n                            matchResult.index = 0;\n                        }\n                    }\n                }\n                if (matchResult && matchResult.index == 0) {\n                    const matchLength = matchResult[0].length;\n                    substring = substring.substr(matchResult[0].length);\n                    const oldIndex = index;\n                    index += matchLength;\n                    if (tokenDefinition.type !== tokenTypes.WHITESPACE) {\n                        if (tokenDefinition.type === tokenTypes.ERROR) {\n                            errors.push(result.length);\n                        }\n                        result.push({\n                            type: tokenDefinition.type,\n                            value: tokenDefinition.value(matchResult),\n                            tightness: tokenDefinition.tightness,\n                            range: {start: oldIndex, end: index}\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        return {string: str, tokens: result, position: 0, errors: errors};\n    }\n\n    resetStream():void {\n        this.stream = {string: \"\", tokens: [], position: 0, errors: []};\n    }\n\n    charPosition():number {\n        return this.currentToken() ? this.currentToken().range.start : this.stream.string.length;\n    }\n\n    remainder():string {\n        const end = this.charPosition();\n        return this.stream.string.substr(end);\n    }\n\n    currentToken():Token {\n        return this.stream.tokens[this.stream.position];\n    }\n\n    advance():void {\n        this.stream.position++;\n    }\n\n    parse(str:string):{tree:ParseTree, errors:Array<ParseTree>, remainder:string} {\n        this.stream = this.tokenize(str);\n        this.parseErrors = [];\n        const tree = this.parseExpression(0);\n        var result = {tree, errors: this.parseErrors, remainder: this.remainder()};\n        this.parseErrors = [];\n        this.resetStream();\n        return result;\n    }\n\n    parseExpression(tightness:number):ParseTree {\n        let token = this.currentToken();\n        let tokenDef = this.tokensByType[token.type];\n        const start = token.range.start;\n        this.advance();\n        let tree = tokenDef.startParse(this, token);\n        tree.range.start = start;\n        tree.range.end = this.charPosition();\n        if (tree.type == ERROR) {\n            return tree;\n        }\n        token = this.currentToken();\n        while (token && tightness < token.tightness) {\n            tokenDef = this.tokensByType[token.type];\n            this.advance();\n            let newTree = tokenDef.extendParse(this, tree, token);\n            newTree.range.start = tree.range.start;\n            newTree.range.end = this.charPosition();\n            if (newTree.type == ERROR) {\n                return newTree;\n            }\n            tree = newTree;\n            token = this.currentToken();\n        }\n        return tree;\n    }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./parser.js\n **/","/* @flow */\n\nimport {parseTypes, isPropositional, BOUND_INFINITE} from \"./parser\";\n\ntype\nInstruction =\n    {type: \"check\", formula: ParseTree, index: number, source? : \"root\" | ParseTree} |\n    {type: \"jump\", target: number, index: number, source? : \"root\" | ParseTree} |\n    {type: \"split\", left: number, right: number, index: number, source? : \"root\" | ParseTree} |\n    {type: \"match\", index: number, source? : \"root\" | ParseTree};\ntype\nProgram = Array < Instruction >;\n\nexport default class Compiler {\n    constructor(_ctx) {\n\n    }\n\n    compileTree(tree:ParseTree, idx:number):Program {\n        console.log(`compile ${tree.type} at index ${idx}`);\n        if (tree.type == parseTypes.GROUP) {\n            // TODO: submatch saving\n            return this.compileTree(tree.children[0], idx);\n        }\n        if (isPropositional(tree)) {\n            console.log(\"tree \" + JSON.stringify(tree) + \":\" + tree.type + \" is propositional\");\n            return [{type: \"check\", formula: tree, index: idx, source: tree}];\n        }\n        if (tree.type == parseTypes.CONCATENATION) {\n            const aIdx = idx;\n            const a = this.compileTree(tree.children[0], aIdx);\n            const bIdx = idx + a.length;\n            const b = this.compileTree(tree.children[1], bIdx);\n            return a.concat(b);\n        }\n        if (tree.type == parseTypes.ALTERNATION) {\n            // branch; but need to compile left first.\n            // left:\n            const aIdx = idx + 1;\n            const left = this.compileTree(tree.children[0], aIdx);\n            const bIdx = aIdx + left.length + 1; // Leave room for jump after left\n            // now we can define branch, which goes before left:\n            const branch = [{type: \"split\", left: aIdx, right: bIdx, index: idx, source: tree}];\n            // right:\n            const right = this.compileTree(tree.children[1], bIdx);\n            const cIdx = bIdx + right.length;\n            const jump = [{type: \"jump\", target: cIdx, index: aIdx + left.length, source: tree}];\n            return branch.concat(left).concat(jump).concat(right);\n        }\n        if (tree.type == parseTypes.INTERSECTION) {\n            // TODO: intersection\n        }\n        if (tree.type == parseTypes.REPETITION) {\n            const greedy = tree.value.greedy;\n            const min = tree.value.lowerBound;\n            const phi = tree.children[0];\n            // min repetitions of phi\n            let preface = [];\n            for (let i = 0; i < min; i++) {\n                const phiPgm = this.compileTree(phi, idx);\n                idx += phiPgm.length;\n                preface.push(...phiPgm);\n            }\n            if (tree.value.upperBound != BOUND_INFINITE) {\n                // M-N repetitions of (phi?)\n                const max = tree.value.upperBound;\n                let optionals = [];\n                let targets = [];\n                for (let i = min; i < max; i++) {\n                    // make room for split li,lZ\n                    idx = idx + 1;\n                    // store jump target li in targets\n                    targets.push(idx);\n                    const phiPgm = this.compileTree(phi, idx);\n                    // make room for phiPgm\n                    idx += phiPgm.length;\n                    optionals.push(phiPgm);\n                }\n                //idx is now just past the end of all the \"optionals\".\n                let repetition = [];\n                for (let i = 0; i < optionals.length; i++) {\n                    repetition.push({\n                        type: \"split\",\n                        left: (greedy ? targets[i] : idx),\n                        right: (greedy ? idx : targets[i]),\n                        index: targets[i] - 1,\n                        source: tree\n                    });\n                    repetition.push(...(optionals[i]));\n                }\n                return preface.concat(repetition);\n            } else {\n                // A: split B, C; but must compile B first to get label for C\n                const aIdx = idx;\n                // make room for the split\n                const bIdx = aIdx + 1;\n                // then put in B\n                const b = this.compileTree(phi, bIdx);\n                const jump = [{type: \"jump\", target: aIdx, index: bIdx + b.length, source: tree}];\n                // then label C\n                const cIdx = bIdx + b.length + 1;\n                const branch = [{\n                    type: \"split\",\n                    left: (greedy ? bIdx : cIdx),\n                    right: (greedy ? cIdx : bIdx),\n                    index: idx,\n                    source: tree\n                }];\n                return preface.concat(branch).concat(b).concat(jump);\n            }\n        }\n        throw new Error(\"Can't compile \" + JSON.stringify(tree));\n        return [];\n    }\n\n    compile(tree:ParseTree, debug:bool = false):Program {\n        if (!tree.type && tree.tree && tree.errors && tree.remainder) {\n            throw new Error(\n                \"Received a ParseResult, but expected a ParseTree.\" +\n                \"Call compile() with the .tree element of \" + tree\n            );\n        }\n        // We preface every program with \"true ..\" so that all Playspecs are effectively start-anchored.\n        // This is as per https://swtch.com/~rsc/regexp/regexp2.html\n        const preface = [\n            {type: \"split\", left: 2, right: 1, index: 0, source: \"root\"},\n            {\n                type: \"check\",\n                formula: {\n                    type: parseTypes.TRUE,\n                    value: true,\n                    children: [],\n                    range: {start: 0, end: 0}\n                },\n                index: 1,\n                source: \"root\"\n            },\n            {type: \"jump\", target: 0, index: 2, source: \"root\"}\n        ];\n        const body = this.compileTree(tree, preface.length);\n        const result = preface.concat(body).concat([{\n            type: \"match\",\n            index: preface.length + body.length,\n            source: \"root\"\n        }]);\n        if (!this.validate(result)) {\n            throw new Error(\n                \"Error compiling tree \" + JSON.stringify(tree) + \" into result \" + JSON.stringify(result)\n            );\n        }\n        if (!debug) {\n            for (let i = 0; i < result.length; i++) {\n                delete result[i].source;\n            }\n        }\n        return result;\n    }\n\n    validate(pgm:Program):bool {\n        // todo: validate programs against some basic sanity checks.\n        //ensure each instruction's index is its index in pgm\n        //ensure no split or jump goes beyond end of program\n        //...\n        return true;\n    }\n\n    stringifyCustom(formula:ParseTree):string {\n        const value = formula.value === undefined ? \"\" : formula.value.toString();\n        const children = formula.children && formula.children.length ?\n            (formula.children.map((c) => this.stringifyFormula(c))).join(\",\") :\n            \"\";\n        return `${formula.type}(${value},${children})`;\n    }\n\n    stringifyFormula(formula:ParseTree):string {\n        switch (formula.type) {\n            case parseTypes.TRUE:\n                return \"true\";\n            case parseTypes.FALSE:\n                return \"false\";\n            case parseTypes.START:\n                return \"start\";\n            case parseTypes.END:\n                return \"end\";\n            case parseTypes.AND:\n                return `${this.stringifyFormula(formula.children[0])} & ${this.stringifyFormula(formula.children[1])}`;\n            case parseTypes.OR:\n                return `${this.stringifyFormula(formula.children[0])} | ${this.stringifyFormula(formula.children[1])}`;\n            case parseTypes.NOT:\n                return `not ${this.stringifyFormula(formula.children[0])}`;\n            case parseTypes.GROUP:\n                return `(${this.stringifyFormula(formula.children[0])})`;\n            default:\n                return this.stringifyCustom(formula);\n        }\n    }\n\n    stringify(code:Program):string {\n        let result = [];\n        for (let i = 0; i < code.length; i++) {\n            const instr = code[i];\n            let instrStr = `${instr.index}:${instr.type}`;\n            switch (instr.type) {\n                case \"split\":\n                    instrStr += ` ${instr.left} ${instr.right}`;\n                    break;\n                case \"jump\":\n                    instrStr += ` ${instr.target}`;\n                    break;\n                case \"check\":\n                    instrStr += \" \" + this.stringifyFormula(instr.formula);\n                    break;\n                case \"match\":\n                    break;\n                default:\n                    throw new Error(\"Unrecognized instruction \" + instr);\n            }\n            if (instr.source) {\n                if (instr.source == \"root\") {\n                    instrStr += \"  \\t\\t(root)\";\n                } else {\n                    if (instr.type == \"check\") {\n                        instrStr += `\\t(ch. ${instr.source.range.start}-${instr.source.range.end})`;\n                    } else {\n                        instrStr += `\\t\\t(${instr.source.type} ${JSON.stringify(instr.source.value)})`;\n                    }\n                }\n            }\n            result.push(instrStr);\n        }\n        return result.join(\"\\n\");\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./compiler.js\n **/","/* @flow */\n\nimport {parseTypes, Parser} from \"./parser.js\";\nimport Compiler from \"./compiler.js\";\n\nexport default class Playspec {\n    constructor(spec:string, context, debug:boolean=false) {\n        this.checkAPI = context.checks;\n        this.traceAPI = context.trace;\n        this.spec = spec;\n        const parser = new Parser(context);\n        const compiler = new Compiler(context);\n        this.parseResult = parser.parse(spec);\n        this.program = compiler.compile(this.parseResult.tree, debug);\n    }\n    check(trace:Trace<State>, state:State, idx:number, formula:ParseTree):Boolean {\n        switch (formula.type) {\n            case parseTypes.TRUE:\n                return true;\n            case parseTypes.FALSE:\n                return false;\n            case parseTypes.START:\n                return idx == 0;\n            case parseTypes.END:\n                return this.traceAPI.isAtEnd(trace);\n            case parseTypes.AND:\n                return this.check(trace, state, idx, formula.children[0]) &&\n                    this.check(trace, state, idx, formula.children[1]);\n            case parseTypes.OR:\n                return this.check(trace, state, idx, formula.children[0]) ||\n                    this.check(trace, state, idx, formula.children[1]);\n            case parseTypes.NOT:\n                return !this.check(trace, state, idx, formula.children[0]);\n            case parseTypes.GROUP:\n                return this.check(trace, state, idx, formula.children[0]);\n            default:\n                if(this.checkAPI[formula.type]) {\n                    return this.checkAPI[formula.type](trace, state, idx, formula);\n                } else {\n                    throw new Error(\"Unrecognized propositional formula\", trace, state, formula);\n                }\n        }\n    }\n    match(trace:Trace<State>, preserveStates:boolean=false):PlayspecResult {\n        return (new PlayspecResult({\n            spec:this,\n            trace,\n            preserveStates\n        }, undefined, undefined)).next();\n    }\n}\n\nclass Thread {\n    constructor(id:number, pc:number, priority:number) {\n        this.id = id;\n        this.pc = pc;\n        this.priority = priority;\n    }\n}\n\nclass PlayspecResult {\n    constructor(\n        config:{spec:Playspec, trace:Trace<State>, preserveStates:boolean},\n        state:{threads:Array<Thread>, maxThreadID:number},\n        match:PlayspecMatchResult\n    ) {\n        this.config = config;\n        this.state = state;\n        if(!this.state) {\n            this.state = {\n                threads:[new Thread(0,0,0)],\n                maxThreadID:0\n            };\n        }\n        this.match = match;\n        if(this.match) {\n            this.start = match.start;\n            this.end = match.end;\n            this.states = match.states;\n        } else {\n            this.start = -1;\n            this.end = -1;\n            this.states = this.config.preserveStates ? [] : null;\n        }\n    }\n    next():PlayspecResult {\n        if(!this.state) {\n            throw new Error(\"Don't call next() on the same PlayspecResult twice!\", this);\n        }\n        // todo: ... interpret ...\n        const result = new PlayspecResult(\n            this.config,\n            this.state,\n            {start:0, end:0, states:this.config.preserveStates ? [] : undefined}\n        );\n        this.state = undefined;\n        return result;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./playspec.js\n **/"],"sourceRoot":""}